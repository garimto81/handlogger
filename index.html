<!-- index  — Poker Hand Logger — v1.1 (2025-10-02) -->
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Poker Hand Logger</title>
<style>
:root{font-size:28px;--bg:#0b0d12;--panel:#101522;--line:#1f2435;--muted:#9aa3b2;--acc:#2a6fff;--text:#e7eaf0}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
header,footer{padding:12px 14px;background:#0f1320;border-bottom:1px solid #222}
.wrap{display:flex;flex-direction:column;gap:12px;padding:12px}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
h3{margin:0 0 10px;color:#a9b8ff;font-size:1rem}
label{font-size:.8rem;color:var(--muted)}
select,input,button{background:#0f1320;color:var(--text);border:1px solid #2a3249;border-radius:12px;padding:12px;font-size:1rem}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:10px}.g2{grid-template-columns:1fr 1fr}
.pill{display:inline-flex;padding:8px 10px;border:1px solid #2a3249;border-radius:999px;cursor:pointer}
.pill.active{background:#223266;border-color:var(--acc)}
.seatCard{padding:10px;border:1px dashed #2a3249;border-radius:12px}
.small{font-size:.8rem}.muted{color:var(--muted)}
.hidden{display:none !important}
.boardWrap{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;max-height:38vh;overflow:auto}
.suitCol{display:grid;grid-template-rows:repeat(13,1fr);gap:6px}
.card{height:54px;border-radius:10px;border:1px solid #2a3249;display:flex;justify-content:center;align-items:center;background:#0f1320;cursor:pointer}
.card.sel{outline:2px solid var(--acc)}
.actionDock{position:sticky;bottom:0;left:0;right:0;background:#0c1120;border-top:1px solid #20263a;padding:12px;z-index:5}
.actionDock .pad{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.actionDock button{height:66px;font-weight:700}
.btnPrimary{background:var(--acc);border-color:var(--acc)}
.holeBadge{display:inline-flex;gap:6px}
.badge{padding:6px 8px;border:1px solid #2a3249;border-radius:999px}
.badge.click{cursor:pointer}
#overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:20}
#overlay .box{width:min(680px,94vw);max-height:80vh;overflow:auto;background:#0f1320;border:1px solid #2a3249;border-radius:14px;padding:12px}
.logbox{max-height:22vh;overflow:auto;border:1px solid #1b2133;border-radius:10px;padding:8px;background:#0e1320}

/* === Review 배지 & 보드 === */
.badgeRow{display:flex;flex-direction:column;gap:8px}
.cardBadge{display:inline-flex;align-items:center;justify-content:center;min-width:68px;height:68px;padding:0 12px;border-radius:12px;border:6px solid #2a3249;background:#ffffff;font-weight:900;font-size:1.25rem}
.cb-s{border-color:#111111;color:#111111} /* spade = black */
.cb-h{border-color:#ef4444;color:#ef4444} /* heart = red */
.cb-d{border-color:#3b82f6;color:#3b82f6} /* diamond = blue*/
.cb-c{border-color:#22c55e;color:#22c55e} /* club = green */
.actBadge{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:3px solid;font-weight:800;width:fit-content}
.act-chk{border-color:#22c55e;background:rgba(34,197,94,.15);color:#eafff0}
.act-call{border-color:#22c55e;background:rgba(34,197,94,.15);color:#eafff0}
.act-bet{border-color:#ef4444;background:rgba(239,68,68,.15);color:#ffe3e3}
.act-raise{border-color:#ef4444;background:rgba(239,68,68,.15);color:#ffe3e3}
.act-fold{border-color:#3b82f6;background:rgba(59,130,246,.15);color:#e6f0ff}
.act-allin{border-color:#b91c1c;background:rgba(185,28,28,.2);color:#ffe5e5}
.streetTitle{margin:10px 0 4px;font-weight:900;color:#a9b8ff}
.playerName{font-weight:800}

/* 설정 토글 */
.settings{display:flex;gap:8px;align-items:center}
.settings input{min-width:220px}

/* === Review 2-Panel 레이아웃 (v1.2.0) === */
#panelReview{display:flex;flex-direction:column;gap:12px}
#reviewContainer{display:flex;gap:12px;width:100%}
#list{flex:0 0 40%;max-height:75vh;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:8px;background:#0e1320}
#detail{flex:1;max-height:75vh;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:12px;background:#0e1320}
.seatCard.selected{border:2px solid var(--acc);background:rgba(42,111,255,.1)}
</style>
</head>
<body>
<header class="row" style="justify-content:space-between">
  <div><strong>Poker Hand Logger</strong><span class="muted small"> · 모바일 최적화 · 기여액 기반 · v1.1</span></div>
  <div class="row">
    <button id="modeRecord" type="button" class="btnPrimary">Record</button>
    <button id="modeReview" type="button">Review</button>
  </div>
</header>

<div class="wrap">
  <div class="panel" id="panelRecord">
    <h3>Record</h3>

    <!-- 외부 시트/BB 설정 -->
    <div class="panel" style="background:#0e1322; margin-bottom:10px">
      <div class="row settings small">
        <label>External Sheet ID</label>
        <input id="extSheetId" type="text" placeholder="예: 13LpVWYH... (VIRTUAL 시트 소속 스프레드시트 ID)"/>
        <label>Big Blind(원)</label>
        <input id="bbInput" type="number" inputmode="numeric" placeholder="예: 1000"/>
        <button id="saveSettingsBtn" type="button">설정 저장</button>
      </div>
      <div class="small muted" id="settingsMsg"></div>
    </div>

    <div class="grid g2">
      <div><label>테이블</label><select id="tableSel"></select></div>
      <div><label>핸드 No.</label><input id="handNo" type="number" placeholder="자동부여(선택)"/></div>
      <div>
        <label>시작 스트릿(고정)</label>
        <select id="streetStart">
          <option value="PREFLOP">Preflop</option>
          <option value="FLOP">Flop</option>
          <option value="TURN">Turn</option>
          <option value="RIVER">River</option>
        </select>
      </div>
      <div><label>BTN 좌석</label><select id="btnSeat"></select></div>
      <div style="grid-column:1/-1"><label>선 누적 팟(pre_pot, 선택)</label><input type="number" id="prePot" placeholder="예: 12500" style="width:100%"/></div>
    </div>

    <div style="margin-top:10px">
      <label>참여 좌석 선택(비참여 제외)</label>
      <div id="seatsRow" class="row"></div>
    </div>

    <div id="stackGrid" class="grid" style="grid-template-columns:1fr; margin-top:10px"></div>

    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div class="row small">
        <b>보드(카드 토글)</b><span class="muted"> · A→2 / ♠→♥→♦→♣ · 재탭 해제 · 5장까지</span>
        <span class="muted">· 현재 스트릿: <b id="curStreetTag">-</b></span>
      </div>
      <div id="boardRowRecord" class="boardWrap" style="margin-top:6px"></div>
    </div>

    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div class="row small">
        <div>현재 차례: <b id="turnSeat">-</b></div>
        <div>· toCall: <b id="toCall">0</b> · pot: <b id="pot">0</b></div>
      </div>
      <div id="actionFeed" class="logbox small"></div>
    </div>

    <div class="actionDock">
      <div class="pad" id="actionPad"></div>
      <div class="row" style="margin-top:8px; width:100%">
        <button id="undoBtn" type="button">Undo</button>
        <button id="newHandBtn" type="button">새 핸드</button>
        <button id="commitBtn" type="button" class="btnPrimary" style="flex:1">데이터 전송(커밋)</button>
        <span id="commitMsg" class="small muted"></span>
      </div>
    </div>
  </div>

  <div class="panel hidden" id="panelReview">
    <h3>Review</h3>
    <div class="row"><button id="refreshList" type="button">새로고침</button><span id="listInfo" class="small muted"></span></div>
    <div id="reviewContainer">
      <div id="list"></div>
      <div id="detail" class="small"></div>
    </div>
  </div>
</div>

<footer class="row"><span class="small muted">BTN만 · 사이드팟 자동계산 없음 · 보드 미완성 허용 · ALL-IN 금액 수동 · v1.1</span></footer>

<!-- 홀카드 선택 오버레이 -->
<div id="overlay"><div class="box">
  <div class="row small"><b id="ovTitle">홀카드 선택</b><span class="muted"> · 2장까지 선택 · 탭=선택/해제</span><span class="muted" id="ovCount"></span></div>
  <div id="boardRowOverlay" class="boardWrap" style="margin-top:6px"></div>
  <div class="row" style="margin-top:10px;justify-content:flex-end"><button type="button" onclick="closeOverlay()">닫기</button></div>
</div></div>

<script>
/* ===== Poker Hand Logger — v1.1 (2025-10-02) ===== */
const S={tables:[],roster:{},cfg:{},
  curTable:null,startStreetInit:'PREFLOP',curStreet:'PREFLOP',
  btnSeat:null,seats:[],activeSeatMap:{},prePot:0,actions:[],nextSeq:1,board:[],
  toCall:0,pot:0,contrib:{},allin:{},folded:{},actorIdx:0,order:[],acted:new Set(),
  holes:{},holePickSeat:null,handNo:'',stacks:{},
  extSheetId:'',bbValue:0};

const SUITS=['s','h','d','c'];
const RANKS=['A','K','Q','J','T','9','8','7','6','5','4','3','2'];

/* ===== 초기 로딩 ===== */
google.script.run.withSuccessHandler(initFromConfig).getConfig();

function initFromConfig(data){
  S.tables=data.tables; S.roster=data.roster; S.cfg=data.config||{};
  // 설정 복원
  S.extSheetId = localStorage.getItem('phl_extSheetId')||'';
  S.bbValue = toInt(localStorage.getItem('phl_bbSize')||'0');
  document.getElementById('extSheetId').value=S.extSheetId;
  document.getElementById('bbInput').value=S.bbValue||'';
  document.getElementById('saveSettingsBtn').onclick=saveSettings_;
  document.getElementById('settingsMsg').textContent= S.extSheetId ? `시트ID 저장됨 · BB=${S.bbValue||'-'}` : '시트ID/BB를 설정하세요';

  const sel=document.getElementById('tableSel');
  sel.innerHTML = `<option value="">테이블 선택</option>${S.tables.map(t=>`<option value="${t}">${t}</option>`).join('')}`;
  sel.onchange=onTableChange;

  const streetSel=document.getElementById('streetStart');
  streetSel.onchange=e=>{ S.startStreetInit=e.target.value; S.curStreet=S.startStreetInit; resetHandState(false); renderAll(); };

  document.getElementById('btnSeat').onchange=e=>{S.btnSeat=toInt(e.target.value); buildTurnOrder(); renderAll();};
  document.getElementById('prePot').oninput=e=>{S.prePot=toInt(e.target.value); S.pot=S.prePot+sumObj(S.contrib); renderPot();};
  document.getElementById('handNo').oninput=e=>{S.handNo=e.target.value||'';};
  document.getElementById('undoBtn').onclick=undoOnce;
  document.getElementById('commitBtn').onclick=commitHand;
  document.getElementById('newHandBtn').onclick=()=>resetHandState(true);
  document.getElementById('refreshList').onclick=()=>loadList(true);
  document.getElementById('modeRecord').onclick=()=>setMode('record');
  document.getElementById('modeReview').onclick=()=>setMode('review');

  // v1.2.0: 무한 스크롤
  document.getElementById('list').addEventListener('scroll', e=>{
    const el=e.target; if(el.scrollHeight-el.scrollTop-el.clientHeight<100) loadList(false);
  });

  setMode('record');
  buildBoardUI('boardRowRecord', toggleBoardCard);
  buildBoardUI('boardRowOverlay', pickCardOverlay);
  document.getElementById('streetStart').value=S.startStreetInit;
  renderAll();
  loadList();
}

function saveSettings_(){
  S.extSheetId = (document.getElementById('extSheetId').value||'').trim();
  S.bbValue = toInt(document.getElementById('bbInput').value||'0');
  localStorage.setItem('phl_extSheetId', S.extSheetId);
  localStorage.setItem('phl_bbSize', S.bbValue);
  document.getElementById('settingsMsg').textContent='저장됨';
  setTimeout(()=>document.getElementById('settingsMsg').textContent='',1500);
}

function setMode(m){
  const rec=document.getElementById('panelRecord'), rev=document.getElementById('panelReview');
  const bR=document.getElementById('modeRecord'), bV=document.getElementById('modeReview');
  if(m==='record'){rec.classList.remove('hidden'); rev.classList.add('hidden'); bR.classList.add('btnPrimary'); bV.classList.remove('btnPrimary');}
  else{rev.classList.remove('hidden'); rec.classList.add('hidden'); bV.classList.add('btnPrimary'); bR.classList.remove('btnPrimary'); loadList(true);}
}

/* ===== 테이블 변경 ===== */
function onTableChange(e){
  S.curTable=e.target.value||null;
  const arr=(S.roster[S.curTable]||[]).slice().sort((a,b)=>a.seat-b.seat);
  S.seats=arr.map(x=>({seat:toInt(x.seat), name:x.player, nation:x.nation, chips:x.chips}));
  S.activeSeatMap={}; S.seats.forEach(s=>S.activeSeatMap[s.seat]=true);
  S.folded={}; S.allin={}; S.stacks={};
  const btnDefault=toInt(S.cfg[S.curTable]?.btn_seat)||'';
  const btnSel=document.getElementById('btnSeat');
  btnSel.innerHTML=`<option value="">BTN 선택</option>${S.seats.map(s=>`<option value="${s.seat}" ${s.seat==btnDefault?'selected':''}>${seatShort(s.seat,s.name)}</option>`).join('')}`;
  S.btnSeat=btnDefault||null; S.handNo=''; document.getElementById('handNo').value='';
  S.curStreet=S.startStreetInit; resetHandState(false); renderAll();
}

/* ===== 핸드 상태 ===== */
function resetHandState(clearInputs){
  S.contrib={}; S.actions=[]; S.nextSeq=1; S.board=[]; S.holes={};
  S.pot=S.prePot; S.toCall=0; S.allin={}; S.folded={}; S.acted=new Set();
  S.curStreet=S.startStreetInit; buildTurnOrder(); renderAll();
  if(clearInputs){ document.getElementById('commitMsg').textContent='새 핸드 시작'; }
}

function buildTurnOrder(){
  const active=S.seats.map(s=>toInt(s.seat)).filter(seat=>S.activeSeatMap[seat]).sort((a,b)=>a-b);
  S.order=[]; if(!active.length){S.actorIdx=0; return;}
  const btn=toInt(S.btnSeat);
  if(S.curStreet!=='PREFLOP'){
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    const rotated=active.slice(start).concat(active.slice(0,start));
    const filtered=rotated.filter(v=>v!==btn); if(active.includes(btn)) filtered.push(btn);
    S.order=filtered;
  }else{
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    S.order=active.slice(start).concat(active.slice(0,start));
  }
  S.actorIdx=0; skipInvalidActors();
}

function skipInvalidActors(){
  if(S.order.length===0) return;
  let guard=0;
  while(guard<50){
    const seat=S.order[S.actorIdx%S.order.length];
    if(!S.activeSeatMap[seat] || S.allin[seat] || S.folded[seat]){ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; continue; }
    break;
  }
}

/* ===== 렌더 ===== */
function renderAll(){ renderSeatToggles(); renderStackGrid(); renderActionPad(); renderTurnSeat(); renderPot(); renderFeed(); syncBoardSelection('boardRowRecord'); document.getElementById('curStreetTag').textContent=S.curStreet; }

function seatShort(seat,name){
  const n=String(name||'').trim(); if(!n) return `#${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `#${seat} ${init}${last}`;
}
function seatNameOnly(seat,name){
  const n=String(name||'').trim(); if(!n) return `Seat ${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `${init}${last}`;
}

function renderSeatToggles(){
  const box=document.getElementById('seatsRow');
  if(!S.seats.length){box.innerHTML='<span class="muted small">테이블을 먼저 선택</span>'; return;}
  box.innerHTML='';
  S.seats.forEach(s=>{
    const el=document.createElement('div');
    el.className='pill '+(S.activeSeatMap[s.seat]?'active':'');
    el.textContent=seatShort(s.seat,s.name);
    el.onclick=()=>{ if(S.actions.length>0) return; S.activeSeatMap[s.seat]=!S.activeSeatMap[s.seat]; buildTurnOrder(); renderAll(); };
    box.appendChild(el);
  });
}

function renderStackGrid(){
  const grid=document.getElementById('stackGrid'); grid.innerHTML='';
  S.seats.filter(s=>S.activeSeatMap[s.seat]).forEach(s=>{
    const [c1,c2]=(S.holes[s.seat]||['','']);
    const wrap=document.createElement('div'); wrap.className='seatCard';
    wrap.innerHTML = `
      <div class="small"><span class="playerName">${seatNameOnly(s.seat,s.name)}</span></div>
      <div class="row">
        <input type="number" placeholder="stack(선택)" value="${S.stacks[s.seat]??''}" oninput="S_setStack(${s.seat}, this.value)" />
      </div>
      <div class="row small" style="margin-top:6px">
        <span class="muted">홀카드:</span>
        <span class="holeBadge">
          <span class="badge click" onclick="openHoleOverlay(${s.seat})">${prettyCard(c1)||'Card1'}/${prettyCard(c2)||'Card2'}</span>
          <button type="button" onclick="clearHole(${s.seat})">지우기</button>
        </span>
      </div>`;
    grid.appendChild(wrap);
  });
}
window.S_setStack=(seat,v)=>{ S.stacks[seat]=toInt(v); };

function renderActionPad(){
  const pad=document.getElementById('actionPad'); pad.innerHTML='';
  const seat=currentActorSeat(); if(!seat){pad.innerHTML='<button type="button" disabled>대기</button>'; return;}
  const hasToCall=S.toCall>0;
  (hasToCall?['CALL','RAISE','FOLD','ALLIN']:['CHECK','BET','FOLD','ALLIN']).forEach(kind=>{
    const el=document.createElement('button'); el.type='button'; el.textContent=kind; el.onclick=()=>onAction(kind,seat); pad.appendChild(el);
  });
}
function renderTurnSeat(){ document.getElementById('turnSeat').textContent=currentActorSeat()?('Seat '+currentActorSeat()):'-'; }
function renderPot(){ document.getElementById('toCall').textContent=S.toCall; document.getElementById('pot').textContent=S.pot; }
function currentActorSeat(){ if(S.order.length===0) return null; return S.order[S.actorIdx%S.order.length]; }

function renderFeed(){
  const box=document.getElementById('actionFeed');
  if(!S.actions.length){ box.innerHTML='<span class="muted">아직 액션 없음</span>'; return; }
  box.innerHTML=S.actions.map(a=>{
    const nm = seatNameOnly(a.seat, getSeatName(a.seat));
    return `#${a.seq} · ${a.street} · ${nm} · ${a.action}${a.amount_input?(' '+a.amount_input):''} → toCall ${a.to_call_after} · pot ${a.pot_after}`;
  }).join('<br/>');
  box.scrollTop=box.scrollHeight;
}

/* ===== 액션 ===== */
function onAction(kind,seat){
  if(kind==='FOLD'){ S.folded[seat]=true; applyAction({seat,action:'FOLD',amt:0}); return; }
  if(kind==='CHECK'){ if(S.toCall>0) return; applyAction({seat,action:'CHECK',amt:0}); return; }
  if(kind==='CALL'){ const need=Math.max(0, maxContribAll()- (S.contrib[seat]||0)); applyAction({seat,action:'CALL',amt:need}); return; }
  if(kind==='BET'||kind==='RAISE'||kind==='ALLIN'){
    let def='';
    if(kind==='ALLIN' && S.stacks[seat]!=null){
      const remain = Math.max(0, S.stacks[seat] - (S.contrib[seat]||0)); def = String(remain);
    }
    const val=prompt(`금액 입력 (${kind})`, def); if(val===null) return;
    applyAction({seat,action:(kind==='ALLIN')?'ALLIN':kind,amt:toInt(val)}); return;
  }
}

function applyAction({seat,action,amt}){
  const prev=S.contrib[seat]||0; S.contrib[seat]=prev+(toInt(amt)||0);
  if(action==='ALLIN') S.allin[seat]=true;
  S.pot=S.prePot+sumObj(S.contrib);
  if(action==='BET'||action==='RAISE'||action==='ALLIN'){ S.acted=new Set([seat]); }
  else if(action==='CHECK'||action==='CALL'){ S.acted.add(seat); }
  computeToCall();
  S.actions.push({seq:S.nextSeq++,street:S.curStreet,seat,action,amount_input:toInt(amt)||0,to_call_after:S.toCall,contrib_after_seat:S.contrib[seat],pot_after:S.pot});
  advanceActor(); renderAll();
  if(isStreetComplete()){
    const nxt=nextStreet(S.curStreet);
    if(nxt){ S.curStreet=nxt; S.acted=new Set(); computeToCall(); buildTurnOrder(); renderAll(); }
  }
}

/* === toCall === */
function maxContribAll(){
  const seats=S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.folded[seat]);
  let m=0; for(const s of seats){ m=Math.max(m, S.contrib[s]||0); } return m;
}
function computeToCall(){
  const maxC=maxContribAll(); let maxNeed=0;
  for(const s of aliveNonAllin()){
    const need=Math.max(0, maxC-(S.contrib[s]||0)); if(need>maxNeed) maxNeed=need;
  }
  S.toCall=maxNeed;
}
function aliveNonAllin(){ return S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.allin[seat] && !S.folded[seat]); }
function advanceActor(){ if(S.order.length===0) return; let guard=0; do{ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; } while(guard<50 && (!S.activeSeatMap[currentActorSeat()] || S.allin[currentActorSeat()] || S.folded[currentActorSeat()])); }
function isStreetComplete(){ const alive=aliveNonAllin(); if(alive.length<=1) return true; const everyoneActed = S.acted && (S.acted.size>=alive.length); return (S.toCall===0 && everyoneActed); }
function nextStreet(st){ if(st==='PREFLOP') return 'FLOP'; if(st==='FLOP') return 'TURN'; if(st==='TURN') return 'RIVER'; return null; }
function undoOnce(){
  if(S.actions.length===0) return;
  const last=S.actions.pop(); S.nextSeq--;
  S.contrib[last.seat]=(S.contrib[last.seat]||0)-(toInt(last.amount_input)||0);
  if(S.contrib[last.seat]<0) S.contrib[last.seat]=0;
  if(last.action==='ALLIN') S.allin[last.seat]=false;
  if(last.action==='FOLD') S.folded[last.seat]=false;
  S.curStreet = S.actions.length ? S.actions[S.actions.length-1].street : S.startStreetInit;
  S.pot=S.prePot+sumObj(S.contrib); computeToCall();
  S.actorIdx=Math.max(0,S.actorIdx-1)%((S.order.length)||1);
  S.acted=new Set(S.actions.filter(a=>a.street===S.curStreet).map(a=>a.seat));
  buildTurnOrder(); renderAll();
}

/* ===== 카드 UI ===== */
function buildBoardUI(containerId, handler){
  const box=document.getElementById(containerId); box.innerHTML='';
  SUITS.forEach(s=>{
    const col=document.createElement('div'); col.className='suitCol';
    RANKS.forEach(r=>{
      const c=r+s; const el=document.createElement('div'); el.className='card';
      el.textContent=prettyCard(c); el.onclick=()=>handler(c,el); col.appendChild(el);
    });
    box.appendChild(col);
  });
}
function prettyCard(cs){
  if(!cs) return ''; const cc=cardCode(cs); const suit=cc.slice(-1), r=cc.slice(0,-1);
  const map={s:'♠',h:'♥',d:'♦',c:'♣'}; return r+map[suit];
}
function toggleBoardCard(card,el){
  const i=S.board.indexOf(card);
  if(i>=0){S.board.splice(i,1); el.classList.remove('sel'); return;}
  if(S.board.length>=5) return;
  S.board.push(card); el.classList.add('sel');
}
function syncBoardSelection(id){
  const box=document.getElementById(id); if(!box) return;
  [...box.querySelectorAll('.card')].forEach(dom=>{
    const c=labelToCode(dom.textContent);
    if(S.board.includes(c)) dom.classList.add('sel'); else dom.classList.remove('sel');
  });
}
function labelToCode(label){
  const r=label.replace(/[♠♥♦♣]/,'').trim();
  const sMap={'♠':'s','♥':'h','♦':'d','♣':'c'}; const sym=label.slice(-1);
  return r + (sMap[sym]||'');
}

/* 홀카드 오버레이(2장 연속 선택) — 보드중복 차단(단방향) */
function openHoleOverlay(seat){
  S.holePickSeat=seat;
  document.getElementById('ovTitle').textContent=`${seatNameOnly(seat, getSeatName(seat))} · 홀카드`;
  updateOvCount_(seat);
  document.getElementById('overlay').style.display='flex';
}
function pickCardOverlay(card,el){
  if(!S.holePickSeat) return;
  // 보드에 이미 있는 카드는 홀카드에서 선택 불가(요청사항 v1.1)
  if(S.board.includes(card)){ return; }

  const seat=S.holePickSeat;
  const arr=S.holes[seat]||['',''];
  const existsIdx = arr.indexOf(card);
  if(existsIdx>=0){ arr[existsIdx]=''; }
  else{
    if(!arr[0]) arr[0]=card;
    else if(!arr[1]) arr[1]=card;
    else { arr[0]=arr[1]; arr[1]=card; }
  }
  S.holes[seat]=arr; renderStackGrid(); updateOvCount_(seat);
  if(arr[0] && arr[1]) closeOverlay();
}
function updateOvCount_(seat){
  const arr=S.holes[seat]||['','']; const n=(arr[0]?1:0)+(arr[1]?1:0);
  document.getElementById('ovCount').textContent=` · 선택 ${n}/2`;
}
function clearHole(seat){ S.holes[seat]=['','']; renderStackGrid(); }
function closeOverlay(){ document.getElementById('overlay').style.display='none'; S.holePickSeat=null; }

/* ===== 커밋/리뷰 ===== */
function commitHand(){
  saveSettings_();
  const payload={
    client_uuid: uuid(),
    event_id:'',
    table_id:S.curTable||'',
    hand_no:(S.handNo||''),
    start_street:S.startStreetInit,
    started_at:new Date().toISOString(),
    ended_at:'',
    btn_seat:S.btnSeat||'',
    board:getBoardObjectForSave(),
    pre_pot:S.prePot||'',
    winner_seat:'',
    pot_final:'',
    actions:S.actions.map(x=>Object.assign({},x)),
    holes:S.holes,
    stack_snapshot:S.stacks
  };
  const msg=document.getElementById('commitMsg'); msg.textContent='저장 중…';
  const ext = { sheetId: (S.extSheetId||'').trim(), bb: S.bbValue||0 };
  google.script.run
    .withSuccessHandler(res=>{
      const extInfo = res && res.external && res.external.updated ? ` · 외부시트 row ${res.external.row} 갱신` :
        (res && res.external && res.external.reason ? ` · 외부시트 스킵(${res.external.reason})` : '');
      msg.textContent=`완료: #${res.hand_no||'-'} (${res.hand_id})${extInfo}`;
      resetHandState(true); loadList();
    })
    .withFailureHandler(err=>{ msg.textContent='오류: '+(err.message||err); })
    .saveHandWithExternal(payload, ext);
}
function getBoardObjectForSave(){
  const b=[...S.board]; // [f1,f2,f3,turn,river]
  return {f1:b[0]||'',f2:b[1]||'',f3:b[2]||'',turn:b[3]||'',river:b[4]||''};
}

/* === Review 상태 관리 (v1.2.0) === */
const reviewState={page:1,size:10,total:0,loading:false,hasMore:true,selectedId:null};

function loadList(reset){
  if(reset){ reviewState.page=1; reviewState.hasMore=true; reviewState.total=0; }
  if(reviewState.loading||!reviewState.hasMore) return;
  reviewState.loading=true;
  const box=document.getElementById('list');
  if(reset) box.innerHTML='<div class="small muted" style="padding:8px">불러오는 중…</div>';
  google.script.run.withSuccessHandler(data=>{
    reviewState.loading=false;
    if(data.error){ box.innerHTML=`<div class="small" style="color:#ffbdbd">오류: ${data.error}</div>`; return; }
    reviewState.total=data.total;
    document.getElementById('listInfo').textContent=`총 ${reviewState.total}건 (${reviewState.page}페이지)`;
    if(reset) box.innerHTML='';
    if(!data.items||data.items.length===0){ reviewState.hasMore=false; return; }
    data.items.forEach(it=>box.appendChild(createListItem(it)));
    reviewState.page++;
    reviewState.hasMore=(box.children.length<reviewState.total);
  }).withFailureHandler(err=>{
    reviewState.loading=false;
    box.innerHTML=`<div class="small" style="color:#ffbdbd">로드 오류: ${(err.message||err)}</div>`;
  }).queryHands({},{num:reviewState.page,size:reviewState.size});
}

function createListItem(it){
  const div=document.createElement('div'); div.className='seatCard'; div.dataset.handId=it.hand_id;
  const arr=boardToArray(it.board||it)||[];
  div.innerHTML=`
    <div><b>#${it.hand_no||'-'}</b> · Table ${it.table_id||'-'} · BTN ${it.btn_seat||'-'} · <span class="badge">${it.start_street||'-'}</span></div>
    <div class="small muted">${it.started_at||''}</div>
    <div class="small muted">Board: ${arr.length?arr.map(prettyCard).join(' '):'-'}</div>`;
  div.onclick=()=>selectAndLoadDetail(it.hand_id,div);
  return div;
}

function selectAndLoadDetail(id,el){
  document.querySelectorAll('#list .seatCard').forEach(d=>d.classList.remove('selected'));
  el.classList.add('selected');
  reviewState.selectedId=id;
  loadDetail(id);
}

/* 상세 */
function loadDetail(id){
  const d = document.getElementById('detail');
  if (!id || String(id).trim() === '') { d.innerHTML = `<div class="small" style="color:#ffbdbd">잘못된 hand id</div>`; return; }
  d.textContent = '상세 불러오는 중…';
  google.script.run
    .withSuccessHandler(x=>{
      try{
        if (!x) { d.innerHTML = `<div class="small" style="color:#ffbdbd">서버 응답 없음(undefined) · id=${id}</div>`; return; }
        if (x.error) { d.innerHTML = `<div class="small" style="color:#ffbdbd">오류: ${x.error} · id=${id}</div>`; return; }
        const head = (x.head && typeof x.head === 'object') ? x.head : {};
        const acts = Array.isArray(x.acts) ? x.acts : (Array.isArray(x.actions) ? x.actions : []);
        const stacks = safeJson_(head.stacks_json||{});
        if (!Object.keys(head).length) {
          const sample = JSON.stringify(x).slice(0,400);
          d.innerHTML = `<div class="small" style="color:#ffbdbd">형식 오류(빈 head) · id=${id}<br/><code>${sample}</code></div>`;
          return;
        }
        d.innerHTML = renderDetailContent(head, acts);
      }catch(err){
        const msg=(err && (err.message||err.toString()))||'unknown';
        d.innerHTML = `<div class="small" style="color:#ffbdbd">클라이언트 렌더 오류: ${msg} · id=${id}</div>`;
      }
    })
    .withFailureHandler(err=>{
      const msg = (err && (err.message || err.toString())) || 'unknown failure';
      d.innerHTML = `<div class="small" style="color:#ffbdbd">로드 실패: ${msg} · id=${id}</div>`;
    })
    .getHandDetail(id);
}

/* ===== Review 렌더 유틸 ===== */
function cardCode(cs){
  if (!cs) return '';
  if (typeof cs === 'string') return cs.trim();
  if (cs.card) return String(cs.card).trim();
  if (cs.rank && cs.suit){
    const r = String(cs.rank).toUpperCase().replace('10','T');
    const map={spade:'s',heart:'h',diamond:'d',club:'c','S':'s','H':'h','D':'d','C':'c'};
    const sRaw=String(cs.suit); const s=map[sRaw]||map[sRaw.toLowerCase()]||sRaw.toLowerCase();
    return r+s;
  }
  if (Array.isArray(cs) && cs.length>=2){
    const r=String(cs[0]).toUpperCase().replace('10','T');
    const s=String(cs[1]).toLowerCase(); return r+s;
  }
  return '';
}
function boardToArray(b){
  if(!b) return [];
  if(Array.isArray(b)) return b.map(cardCode).filter(Boolean);
  // 서버 응답 포맷: {f1,f2,f3,turn,river} 또는 {board_f1,board_f2,...}
  const keys=['f1','f2','f3','turn','river'].map(k=>cardCode(b[k])).filter(Boolean);
  if(keys.length) return keys;
  const keys2=['board_f1','board_f2','board_f3','board_turn','board_river'].map(k=>cardCode(b[k])).filter(Boolean);
  return keys2.length?keys2:(b.board?boardToArray(b.board):[]);
}
function boardBadges(b){
  const arr=boardToArray(b); if(!arr.length) return '<span class="muted">-</span>';
  return `<div style="display:flex;gap:10px;flex-wrap:wrap">${arr.map(cs=>{
    const cc=cardCode(cs); if(!cc) return '';
    const suit=cc.slice(-1), r=cc.slice(0,-1);
    const sym=suit==='s'?'♠':suit==='h'?'♥':suit==='d'?'♦':'♣';
    const cl=suit==='s'?'cb-s':suit==='h'?'cb-h':suit==='d'?'cb-d':'cb-c';
    return `<span class="cardBadge ${cl}">${r}${sym}</span>`;
  }).join('')}</div>`;
}
function getSeatName(seat){
  const s = (S.roster[S.curTable]||[]).find(x=>toInt(x.seat)===toInt(seat));
  return s?.player || `Seat ${seat}`;
}
function seatNameOnlyFmt(seat){ return seatNameOnly(seat, getSeatName(seat)); }
function groupByStreet(acts){
  const g={PREFLOP:[],FLOP:[],TURN:[],RIVER:[]};
  (acts||[]).forEach(a=>{ const s=(a.street||'').toUpperCase(); if(g[s]) g[s].push(a); else g.RIVER.push(a); });
  return g;
}
function formatStreetSection(title, arr){
  if(!arr||!arr.length) return '';
  const badges=arr.map(a=>{
    const name=seatNameOnly(a.seat, getSeatName(a.seat));
    const amt=a.amount_input?` ${a.amount_input}`:'';
    const k=(a.action||'').toUpperCase();
    const cl=k==='CHECK'?'act-chk':k==='CALL'?'act-call':k==='BET'?'act-bet':k==='RAISE'?'act-raise':k==='ALLIN'?'act-allin':'act-fold';
    return `<span class="actBadge ${cl}">${name} ${a.action}${amt} · pot ${a.pot_after}</span>`;
  }).join('');
  return `<div class="streetTitle">${title}</div><div class="badgeRow">${badges}</div>`;
}
function renderDetailContent(head,acts){
  const b=head.board||head||{}; const g=groupByStreet(acts||[]);
  const stacks = safeJson_(head.stacks_json||'{}'); const holes = safeJson_(head.holes_json||'{}');
  const stackLine = (stacks && Object.keys(stacks).length)
    ? `<div class="small muted" style="margin:6px 0">Stacks @${head.start_street||''}: `
      + Object.keys(stacks).sort((a,b)=>a-b).map(s=>`${seatNameOnlyFmt(s)}=${stacks[s]}`).join(', ')
      + `</div>` : '';
  const holeLine = (holes && Object.keys(holes).length)
    ? `<div class="small muted" style="margin:6px 0">Holes: `
      + Object.keys(holes).sort((a,b)=>a-b).map(s=>{
          const v=holes[s]||[]; const h=(v[0]&&v[1])?`${prettyCard(v[0])}${prettyCard(v[1])}`:'-';
          return `${seatNameOnlyFmt(s)}=${h}`;
        }).join(', ')
      + `</div>` : '';

  return `<div class="small">Hand #${head.hand_no||'-'} · ${head.hand_id||''}</div>
    <div class="small">Table ${head.table_id||'-'} · BTN ${head.btn_seat||'-'} · <b>시작: ${head.start_street||'-'}</b></div>
    <div style="margin-top:8px">${boardBadges(b)}</div>
    ${stackLine}
    ${holeLine}
    ${formatStreetSection('PREFLOP', g.PREFLOP)}
    ${formatStreetSection('FLOP', g.FLOP)}
    ${formatStreetSection('TURN', g.TURN)}
    ${formatStreetSection('RIVER', g.RIVER)}`;
}

/* ===== 유틸 ===== */
function sumObj(o){ return Object.values(o||{}).reduce((a,b)=>a+(toInt(b)||0),0); }
function toInt(v){ const n=parseInt(v,10); return isNaN(n)?0:n; }
function uuid(){ return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)); }
function safeJson_(s){ try{return typeof s==='string'?JSON.parse(s||'{}'):(s||{});}catch(e){return {}} }
</script>
</body>
</html>
