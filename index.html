<!-- index — Poker Hand Logger — v3.9.0 (2025-01-18) -->
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Poker Hand Logger</title>
<!-- CSS embedded in style tag below -->
<style>
/* v2.6.0: 100vh No-Scroll 레이아웃 */
:root{font-size:28px;--bg:#0b0d12;--panel:#101522;--line:#1f2435;--muted:#9aa3b2;--acc:#2a6fff;--text:#e7eaf0}
*{box-sizing:border-box}
html,body{margin:0;padding:0;height:100vh;overflow:hidden;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
body{display:grid;grid-template-rows:6vh 1fr auto;grid-template-areas:"header" "main" "footer"}
header{grid-area:header;display:flex;justify-content:space-between;align-items:center;padding:0 10px;background:#0f1320;border-bottom:1px solid #222;font-size:0.8rem}
footer{grid-area:footer;position:sticky;bottom:0;padding:8px 10px;background:#0f1320;border-top:2px solid var(--acc);z-index:10}
.wrap{grid-area:main;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
h3{margin:0 0 10px;color:#a9b8ff;font-size:1rem}
label{font-size:.8rem;color:var(--muted)}
select,input,button{background:#0f1320;color:var(--text);border:1px solid #2a3249;border-radius:12px;padding:12px;font-size:1rem}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:10px}.g2{grid-template-columns:1fr 1fr}
.pill{display:inline-flex;align-items:center;justify-content:center;min-width:36px;height:36px;padding:0 8px;border:1px solid #2a3249;border-radius:999px;cursor:pointer;font-size:0.75rem}
.pill.active{background:#223266;border-color:var(--acc)}
.seatCard{padding:10px;border:1px dashed #2a3249;border-radius:12px}
.small{font-size:.8rem}.muted{color:var(--muted)}
.hidden{display:none !important}
/* v2.5.0: 4×13 그리드 (Bottom Sheet용) */
.boardWrap{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;max-height:65vh;overflow:auto;padding:4px}
.suitCol{display:grid;grid-template-rows:repeat(13,1fr);gap:8px}
.card{min-height:56px;border-radius:10px;border:2px solid #2a3249;display:flex;justify-content:center;align-items:center;background:#0f1320;cursor:pointer;font-size:1.1rem;font-weight:700;touch-action:manipulation;user-select:none;transition:all 0.15s}
.card:active{transform:scale(0.95);background:#1a2035}
.card.sel{outline:3px solid var(--acc);background:#223266}
.actionDock{position:sticky;bottom:0;left:0;right:0;background:#0c1120;border-top:1px solid #20263a;padding:12px;z-index:5}
.actionDock .pad{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.actionDock button{height:66px;font-weight:700}
.btnPrimary{background:var(--acc);border-color:var(--acc)}
.holeBadge{display:inline-flex;gap:6px}
.badge{padding:6px 8px;border:1px solid #2a3249;border-radius:999px}
.badge.click{cursor:pointer}

/* v2.5.0: Bottom Sheet (기존 overlay 대체) */
#overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:flex-end;justify-content:center;z-index:20;opacity:0;transition:opacity 0.3s}
#overlay.show{opacity:1}
#overlay .box{width:100%;max-width:680px;max-height:85vh;background:#0f1320;border:1px solid #2a3249;border-radius:20px 20px 0 0;padding:16px;transform:translateY(100%);transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);will-change:transform}
#overlay.show .box{transform:translateY(0)}
.logbox{max-height:22vh;overflow:auto;border:1px solid #1b2133;border-radius:10px;padding:8px;background:#0e1320}

/* === Review 배지 & 보드 (v3.1.0: 밀도 최적화) === */
.badgeRow{display:flex;flex-wrap:wrap;gap:4px}
.cardBadge{display:inline-flex;align-items:center;justify-content:center;min-width:32px;height:32px;padding:0 4px;border-radius:6px;border:2px solid;background:#ffffff;font-weight:700;font-size:0.85rem}
.cb-s{border-color:#111111;color:#111111}
.cb-h{border-color:#ef4444;color:#ef4444}
.cb-d{border-color:#ef4444;color:#ef4444}
.cb-c{border-color:#111111;color:#111111}
/* v3.8.0: 구버전 actBadge (Record 탭에서 사용) */
.actBadge-legacy{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px;border:1px solid;font-weight:600;font-size:0.75rem;white-space:nowrap}
.act-chk{border-color:#22c55e;background:rgba(34,197,94,.1);color:#86efac}
.act-call{border-color:#22c55e;background:rgba(34,197,94,.1);color:#86efac}
.act-bet{border-color:#ef4444;background:rgba(239,68,68,.1);color:#fca5a5}
.act-raise{border-color:#ef4444;background:rgba(239,68,68,.1);color:#fca5a5}
.act-fold{border-color:#3b82f6;background:rgba(59,130,246,.1);color:#93c5fd}
.act-allin{border-color:#b91c1c;background:rgba(185,28,28,.15);color:#fca5a5}
.streetTitle{margin:8px 0 2px;font-weight:700;font-size:0.8rem;color:#94a3b8;cursor:pointer;user-select:none}
.streetTitle:hover{color:#a9b8ff}
.playerName{font-weight:700}

/* 설정 토글 */
.settings{display:flex;gap:8px;align-items:center}
.settings input{min-width:220px}

/* v2.4.0: 키플레이어 하이라이트 */
.pill.keyplayer{background:linear-gradient(135deg,#fbbf24,#f59e0b);border-color:#f59e0b;color:#000;font-weight:800}
.pill.keyplayer.active{background:linear-gradient(135deg,#fcd34d,#fbbf24);box-shadow:0 0 12px rgba(251,191,36,0.6)}

/* v2.6.0: Context Bar (1줄 압축) */
.contextBar{display:flex;gap:8px;align-items:center;padding:8px 12px;background:#0e1322;border-radius:10px;font-size:0.75rem;overflow-x:auto;white-space:nowrap}
.contextBar .item{padding:4px 10px;border-radius:8px;background:#1a2035;border:1px solid #2a3249}
.contextBar .item.active{background:#223266;border-color:var(--acc)}

/* v2.6.0: Seats Pills (원형, 가로 스크롤) */
.seatsWrap{display:flex;gap:8px;overflow-x:auto;padding:8px 0}
.seatPill{min-width:64px;height:64px;display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:999px;border:2px solid #2a3249;background:#0f1320;cursor:pointer;font-size:0.7rem;text-align:center;flex-shrink:0}
.seatPill.active{background:#223266;border-color:var(--acc)}
.seatPill.keyplayer{background:linear-gradient(135deg,#fbbf24,#f59e0b);border-color:#f59e0b;color:#000;font-weight:800}

/* v2.9.0: Keyplayer 테이블 드롭다운 강조 */
select#tableSel option.keyplayer-option {
  font-weight: 800;
  background: linear-gradient(135deg, #fef3c7, #fde68a);
  color: #92400e;
}

/* 선택된 keyplayer 테이블 (closed dropdown) */
select#tableSel:has(option.keyplayer-option:checked) {
  font-weight: 700;
  color: #92400e;
}

/* === Review 2-Panel 레이아웃 (v3.0.0: 9:16 최적화) === */
#panelReview{display:flex;flex-direction:column;gap:12px;height:100%}
#reviewContainer{display:flex;gap:12px;width:100%;height:calc(100vh - 200px);overflow:hidden}
#list{flex:0 0 35%;height:100%;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:8px;background:#0e1320}
#detail{flex:1;height:100%;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:12px;background:#0e1320;scrollbar-width:thin;scrollbar-color:#2a3249 #0e1320}
#detail::-webkit-scrollbar{width:8px}
#detail::-webkit-scrollbar-track{background:#0e1320}
#detail::-webkit-scrollbar-thumb{background:#2a3249;border-radius:4px}
.seatCard.selected{border:2px solid var(--acc);background:rgba(42,111,255,.1)}

/* === Review 상세 디자인 (v3.8.0: Minimal 개선) === */
.potHeader{padding:4px 0;border-bottom:1px solid var(--line);margin-bottom:6px;font-size:0.7rem}
.potHeader-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:2px}
.potHeader-bottom{display:flex;justify-content:space-between;font-size:0.65rem;color:#64748b}
.boardSection{margin:4px 0}
.playerSection{margin:4px 0}
.playerRow{display:flex;gap:4px;padding:1px 0;align-items:center;font-size:0.7rem;flex-wrap:wrap}
.playerSeat{font-weight:700;min-width:32px;color:var(--muted);font-size:0.65rem}
.playerName{font-weight:700;min-width:50px}
.playerHole{display:flex;gap:2px}
.playerStack{color:var(--muted);margin-left:auto}
.sectionDivider{height:1px;background:var(--line);margin:4px 0}
.potFooter{display:none}
.cardBadgeSmall{display:inline-flex;align-items:center;justify-content:center;min-width:28px;height:28px;padding:0 4px;border-radius:4px;border:2px solid;background:#ffffff;font-size:0.7rem;font-weight:700}
.boardSmall{display:flex;gap:3px;margin-top:3px;flex-wrap:wrap}
.detailMeta{font-size:0.7rem;color:var(--muted);margin:2px 0}
.streetRow{margin:6px 0;font-size:0.7rem}
.streetTitle{display:block;cursor:pointer;font-weight:700;color:#94a3b8;margin-bottom:4px;user-select:none;font-size:0.7rem}
.streetTitle:hover{color:#a9b8ff}
.streetBadges{display:flex;flex-direction:column;gap:3px}
.actBadge{display:flex;justify-content:space-between;align-items:center;padding:4px 6px;border-radius:4px;border-left:3px solid;font-weight:600;font-size:0.7rem;background:rgba(15,19,32,0.4)}
.actBadge.raise{border-color:#ef4444;background:rgba(239,68,68,0.08)}
.actBadge.call{border-color:#22c55e;background:rgba(34,197,94,0.08)}
.actBadge.fold{border-color:#3b82f6;background:rgba(59,130,246,0.05);opacity:0.6}
.actBadge.check{border-color:#64748b;background:rgba(100,116,139,0.05);opacity:0.7}
.actBadge .left{display:flex;gap:4px;align-items:center}
.actBadge .name{font-weight:600;min-width:40px}
.actBadge .action{font-size:0.65rem;opacity:0.7}
.actBadge .amount{font-weight:700;font-size:0.75rem;color:#fbbf24}
</style>
</head>
<body>
<header>
  <div style="display:flex;align-items:center;gap:8px">
    <span style="width:6px;height:6px;background:var(--acc);border-radius:50%"></span>
    <strong id="currentMode">Record</strong>
  </div>
  <div style="display:flex;align-items:center;gap:8px">
    <span class="muted small">v3.9.0</span>
    <button id="modeRecord" type="button" class="btnPrimary" style="padding:4px 12px;height:auto;font-size:0.7rem">Rec</button>
    <button id="modeReview" type="button" style="padding:4px 12px;height:auto;font-size:0.7rem">Rev</button>
  </div>
</header>

<!-- v3.6.0: 스마트 적응형 로딩 오버레이 (Adaptive Loading) -->
<div id="loadingOverlay" style="position:fixed;inset:0;background:rgba(11,13,18,0.95);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:100;opacity:0;transition:opacity 0.25s ease">
  <div id="loadingCard" style="text-align:center;background:#101522;border:1px solid #2a3249;border-radius:20px;padding:24px 32px;min-width:280px;box-shadow:0 8px 32px rgba(0,0,0,0.6);transition:all 0.25s ease">
    <div id="loadingTitle" style="font-size:1.2rem;font-weight:700;margin-bottom:20px;color:#a9b8ff">Poker Hand Logger</div>
    <div style="width:100%;height:6px;background:#1f2435;border-radius:3px;overflow:hidden;margin-bottom:12px">
      <div id="loadingBar" style="width:0%;height:100%;background:var(--acc);transition:width 0.3s ease"></div>
    </div>
    <div id="loadingText" style="font-size:0.75rem;color:var(--muted);margin-bottom:4px">초기화 중...</div>
    <div id="loadingDetail" style="font-size:0.65rem;color:#64748b;min-height:16px">0%</div>
  </div>
</div>

<div class="wrap">
  <div class="panel" id="panelRecord">
    <!-- v3.3.2: EXTREME MINIMAL - 모든 헤더 제거, placeholder로 이동 -->
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
      <select id="tableSel" style="width:100%"></select>
      <input id="bbInput" type="text" inputmode="numeric" placeholder="Big Blind (예: 1,000)" style="width:100%"/>
    </div>

    <!-- v3.3.2: 상세 설정 (항상 표시, 헤더 없음) -->
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">
      <input id="handNo" type="number" placeholder="핸드 No. (자동)" style="width:100%"/>
      <select id="btnSeat" style="width:100%"><option value="">BTN 좌석</option></select>
      <select id="streetStart" style="width:100%">
        <option value="PREFLOP">시작: Preflop</option>
        <option value="FLOP">시작: Flop</option>
        <option value="TURN">시작: Turn</option>
        <option value="RIVER">시작: River</option>
      </select>
      <input type="text" inputmode="numeric" id="prePot" placeholder="선 누적 팟 (예: 12,500)" style="width:100%"/>
    </div>

    <!-- v3.3.2: 플레이어 Pills (반응형 가로 배치) -->
    <div id="seatsRow" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px"></div>

    <!-- v3.3.2: 스택 접기 -->
    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="toggleStackSection()">
        <span class="small"><b>💰 스택 & 홀카드</b> <span class="muted" id="stackSummary">0/0명</span></span>
        <span id="stackToggle">▼</span>
      </div>
      <div id="stackGrid" class="grid" style="grid-template-columns:1fr;margin-top:10px;display:none"></div>
    </div>

    <!-- v3.3.2: 보드 - 오버레이만 -->
    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <span class="small"><b>🃏 보드</b> · <span class="muted" id="curStreetTag">-</span></span>
        <button type="button" onclick="openBoardOverlay()" style="padding:4px 10px;height:auto;font-size:0.7rem">+카드</button>
      </div>
      <div id="boardDisplay" style="margin-top:6px;min-height:32px">
        <span class="muted small">선택된 카드 없음</span>
      </div>
    </div>

    <!-- v3.3.2: 턴 정보 + 액션 -->
    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div class="small" style="margin-bottom:6px">
        <div style="margin-bottom:4px">→ <b id="turnSeat">-</b></div>
        <div class="muted">toCall: <b id="toCall">0</b> · pot: <b id="pot">0</b></div>
      </div>

      <!-- v3.3.2: 액션 버튼 (1줄 4개, 44px) -->
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px">
        <div id="actionPad" style="display:contents"></div>
      </div>

      <!-- v3.3.2: 액션 기록 (스크롤) -->
      <div id="actionFeed" class="small" style="max-height:120px;overflow-y:auto;border:1px solid #1b2133;border-radius:6px;padding:6px;background:#0e1320"></div>
    </div>
  </div>

  <div class="panel hidden" id="panelReview">
    <!-- v3.8.0: 1줄 압축 헤더 (설정 버튼 + 새로고침 + 정보) -->
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;gap:8px">
      <h3 style="margin:0">Review</h3>
      <div style="display:flex;align-items:center;gap:8px;flex:1">
        <button id="settingsBtn" type="button" style="padding:4px 10px;height:auto;font-size:0.7rem">⚙️ 설정</button>
        <button id="refreshList" type="button" style="padding:4px 10px;height:auto;font-size:0.7rem">🔄</button>
        <span id="listInfo" class="small muted" style="margin-left:auto"></span>
      </div>
    </div>

    <!-- v3.8.0: VIRTUAL 설정 모달 (접기/펼치기) -->
    <div id="settingsPanel" class="panel" style="background:#0e1322;margin-bottom:10px;display:none">
      <div class="row settings small">
        <label>VIRTUAL Sheet ID</label>
        <input id="virtualSheetId" type="text" placeholder="예: 13LpVWYH... (VIRTUAL 시트 소속 스프레드시트 ID)"/>
        <button id="saveVirtualBtn" type="button">저장</button>
      </div>
      <div class="small muted" id="virtualMsg"></div>
    </div>

    <div id="reviewContainer">
      <div id="list"></div>
      <div id="detail" class="small"></div>
    </div>
  </div>
</div>

<footer id="recordFooter">
  <!-- v3.8.0: Record 탭 전용 Footer (Review 탭에서는 숨김) -->
  <div style="display:flex;gap:6px;margin-bottom:4px">
    <button id="undoBtn" type="button" style="flex:1;padding:8px;height:44px;font-size:0.75rem">← Undo</button>
    <button id="newHandBtn" type="button" style="flex:1;padding:8px;height:44px;font-size:0.75rem">🔄 새 핸드</button>
    <button id="commitBtn" type="button" class="btnPrimary" style="flex:2;padding:8px;height:44px;font-size:0.8rem;font-weight:700">💾 전송</button>
  </div>
  <div id="commitMsg" class="small muted" style="text-align:center;min-height:16px"></div>
</footer>

<!-- v2.5.0: Bottom Sheet 홀카드 선택 -->
<div id="overlay"><div class="box">
  <div style="width:40px;height:4px;background:#4a5568;border-radius:2px;margin:0 auto 12px"></div>
  <div class="row small" style="margin-bottom:12px"><b id="ovTitle">홀카드 선택</b><span class="muted"> · 2장까지</span><span class="muted" id="ovCount"></span></div>
  <div id="boardRowOverlay" class="boardWrap"></div>
  <div class="row" style="margin-top:12px;justify-content:center"><button type="button" onclick="closeOverlay()" style="min-width:120px;height:48px">닫기</button></div>
</div></div>

<script>
/* ===== Poker Hand Logger — v3.9.0 (2025-01-18) ===== */
const S={tables:[],roster:{},cfg:{},
  curTable:null,startStreetInit:'PREFLOP',curStreet:'PREFLOP',
  btnSeat:null,seats:[],activeSeatMap:{},prePot:0,actions:[],nextSeq:1,board:[],
  toCall:0,pot:0,contrib:{},allin:{},folded:{},actorIdx:0,order:[],acted:new Set(),
  holes:{},holePickSeat:null,handNo:'',stacks:{},
  virtualSheetId:'',bbValue:0,
  nextHandNo:1, // v3.3.0: 다음 핸드 번호 (자동 증가)
  sentHandIds:new Set()}; // v3.6.3: VIRTUAL 중복 전송 방지

const SUITS=['s','h','d','c'];
const RANKS=['A','K','Q','J','T','9','8','7','6','5','4','3','2'];

/* v2.5.0: 햅틱 피드백 상수 */
const HAPTIC={LIGHT:20,MEDIUM:30,STRONG:50};
function vibrate(ms){if(navigator.vibrate) navigator.vibrate(ms);}

/* v2.6.0: SessionStorage 캐싱 (1분 TTL) */
function cacheGet(key){
  const cached=sessionStorage.getItem(key);
  if(!cached) return null;
  try{
    const obj=JSON.parse(cached);
    if(Date.now()-obj.timestamp<60000) return obj.data;
    sessionStorage.removeItem(key);
  }catch(e){}
  return null;
}
function cacheSet(key,data){ sessionStorage.setItem(key,JSON.stringify({timestamp:Date.now(),data})); }

/* v2.6.0: PERF 측정 */
const PERF={};
function perfStart(label){PERF[label]=performance.now();}
function perfEnd(label){if(PERF[label])console.log(`[PERF] ${label}: ${(performance.now()-PERF[label]).toFixed(1)}ms`);}

/* ===== v3.6.0: 스마트 적응형 로딩 시스템 (Smart Adaptive Loading) ===== */

const LOADING = {
  total: 6,
  current: 0,
  steps: [
    '설정 데이터 로딩 중...',
    '테이블 정보 초기화 중...',
    'UI 컴포넌트 준비 중...',
    '이벤트 리스너 등록 중...',
    '화면 렌더링 중...',
    '완료!'
  ],
  // v3.6.0: 적응형 로딩 상태
  startTime: 0,
  timer: null,
  mode: 'full', // 'full' | 'compact'
  haptic: false  // 햅틱 피드백 여부
};

/**
 * 스마트 로딩 표시 (300ms 미만 작업은 자동 숨김)
 * @param {string} message - 메시지
 * @param {object} options - { mode: 'full'|'compact', percent: 0-100, detail: '', haptic: false }
 */
function showLoading(message, options = {}){
  const { mode = 'full', percent = 0, detail = '', haptic = false } = options;

  LOADING.startTime = Date.now();
  LOADING.mode = mode;
  LOADING.haptic = haptic;

  // 300ms 지연 후 표시 (깜빡임 방지)
  LOADING.timer = setTimeout(() => {
    const overlay = document.getElementById('loadingOverlay');
    const card = document.getElementById('loadingCard');
    const title = document.getElementById('loadingTitle');
    const bar = document.getElementById('loadingBar');
    const text = document.getElementById('loadingText');
    const detailEl = document.getElementById('loadingDetail');

    if(!overlay) return;

    // 모드 적용
    if(mode === 'compact'){
      overlay.style.background = 'rgba(11,13,18,0.75)'; // 더 투명
      card.style.minWidth = '240px';
      card.style.padding = '20px 24px';
      title.style.display = 'none'; // 타이틀 숨김
    } else {
      overlay.style.background = 'rgba(11,13,18,0.95)';
      card.style.minWidth = '280px';
      card.style.padding = '24px 32px';
      title.style.display = 'block';
    }

    // 내용 업데이트
    if(bar) bar.style.width = percent + '%';
    if(text) text.textContent = message;
    if(detailEl) detailEl.textContent = detail || Math.round(percent) + '%';

    // 표시
    overlay.style.display = 'flex';
    setTimeout(() => overlay.style.opacity = '1', 10);

    console.log(`[LOAD] ${mode.toUpperCase()} - ${Math.round(percent)}% - ${message}${detail ? ' - ' + detail : ''}`);
  }, 300);
}

/**
 * 로딩 숨김 (햅틱 자동 처리)
 * @param {boolean} success - 성공 여부 (햅틱 트리거)
 */
function hideLoading(success = true){
  // 타이머 취소 (300ms 전 완료 시)
  if(LOADING.timer){
    clearTimeout(LOADING.timer);
    LOADING.timer = null;
  }

  const elapsed = Date.now() - LOADING.startTime;
  const overlay = document.getElementById('loadingOverlay');

  if(!overlay || overlay.style.display === 'none'){
    console.log(`[LOAD] 완료 (${elapsed}ms) - 표시 안 됨 (빠른 작업)`);
    return;
  }

  // 햅틱 피드백 (중요 작업만)
  if(success && LOADING.haptic){
    vibrate(HAPTIC.STRONG);
  }

  // 페이드아웃
  overlay.style.opacity = '0';
  setTimeout(() => {
    overlay.style.display = 'none';
    console.log(`[LOAD] 완료 (${elapsed}ms)`);
  }, 250);
}

/**
 * 레거시 호환 함수 (기존 updateLoading 유지)
 */
function updateLoading(step, percent, detail){
  const mainMsg = LOADING.steps[step] || '로딩 중...';
  const displayMsg = detail ? `${mainMsg} - ${detail}` : mainMsg;

  showLoading(mainMsg, {
    mode: 'full',
    percent: percent,
    detail: detail || Math.round(percent) + '%',
    haptic: false
  });
}

/* ===== v2.9.0: Keyplayer 테이블 우선 정렬 ===== */
/**
 * keyplayer가 있는 테이블을 최상단으로 정렬 (Record 모드용)
 * - keyplayer ≥ 1명: 최상단 그룹 (번호순 정렬)
 * - keyplayer 0명: 하단 그룹 (번호순 정렬)
 * - 하위 호환: keyplayer 컬럼 없으면 모든 테이블 일반 처리
 *
 * @param {string[]} tables - 테이블 ID 배열 (예: ['1', '15', '2', '23'])
 * @param {Object} roster - S.roster 객체 {tableId: [{seat, player, keyplayer}, ...]}
 * @returns {string[]} 정렬된 테이블 배열 (keyplayer 테이블 우선)
 */
function sortTablesByKeyplayer(tables, roster) {
  // 입력 검증
  if (!tables || !Array.isArray(tables) || tables.length === 0) {
    return [];
  }

  // roster 없으면 원본 번호순 정렬 (하위 호환)
  if (!roster || Object.keys(roster).length === 0) {
    console.warn('[v2.9.0] sortTablesByKeyplayer: roster 데이터 없음 - 번호순 정렬로 fallback');
    return tables.slice().sort(sortByNumber_);
  }

  const withKeyplayer = [];
  const withoutKeyplayer = [];

  // 각 테이블의 keyplayer 여부 체크
  tables.forEach(tableId => {
    const players = roster[tableId] || [];

    // keyplayer 필드 안전 접근 (undefined → false)
    const hasKeyplayer = players.some(p => p.keyplayer === true);

    if (hasKeyplayer) {
      withKeyplayer.push(tableId);
    } else {
      withoutKeyplayer.push(tableId);
    }
  });

  // 각 그룹 내부를 번호순 정렬
  withKeyplayer.sort(sortByNumber_);
  withoutKeyplayer.sort(sortByNumber_);

  // keyplayer 테이블 최상단 배치
  return [...withKeyplayer, ...withoutKeyplayer];
}

/**
 * 테이블 번호 기준 정렬 (숫자 변환 지원)
 * @param {string} a - 테이블 ID
 * @param {string} b - 테이블 ID
 * @returns {number} 정렬 순서
 */
function sortByNumber_(a, b) {
  const numA = parseInt(a, 10);
  const numB = parseInt(b, 10);

  // 숫자 변환 실패 시 문자열 비교
  if (isNaN(numA) || isNaN(numB)) {
    return String(a).localeCompare(String(b));
  }

  return numA - numB;
}

/* ===== 초기 로딩 ===== */
perfStart('init');
updateLoading(0, 0); // Step 0: 설정 데이터 로딩 중

const cachedConfig=cacheGet('phl_config');
if(cachedConfig){
  console.log('[CACHE] 캐시된 설정 사용');
  updateLoading(0, 20, '캐시에서 로드');
  setTimeout(() => initFromConfig(cachedConfig), 10); // 비동기로 실행 (프로그레스바 표시 시간 확보)
}
else{
  console.log('[SERVER] 서버에서 설정 로딩');
  updateLoading(0, 10, 'Google Apps Script 호출');
  google.script.run
    .withSuccessHandler(d=>{
      updateLoading(0, 20, '서버 응답 수신');
      cacheSet('phl_config',d);
      initFromConfig(d);
    })
    .getConfig();
}

function initFromConfig(data){
  perfEnd('init');

  // Step 1: 테이블 정보 초기화 (20% → 40%)
  updateLoading(1, 25, 'roster 파싱 중');
  S.roster=data.roster; S.cfg=data.config||{};

  updateLoading(1, 30, 'keyplayer 테이블 정렬');
  // v2.9.0: keyplayer 테이블 우선 정렬 (Record 모드용)
  S.tables = sortTablesByKeyplayer(data.tables, S.roster);

  updateLoading(1, 35, '로컬 설정 복원');
  // 설정 복원 (v2.3.0: virtualSheetId는 Review용)
  S.virtualSheetId = localStorage.getItem('phl_virtualSheetId')||'';
  S.bbValue = toInt(localStorage.getItem('phl_bbSize')||'0');

  updateLoading(1, 38, 'BB 입력 포맷팅');
  // v3.3.0: BB 입력 포맷팅
  const bbInput = document.getElementById('bbInput');
  bbInput.value = S.bbValue ? formatNumber(S.bbValue) : '';
  bbInput.addEventListener('input', e => {
    const cursorPos = e.target.selectionStart;
    const oldLen = e.target.value.length;
    const cleaned = parseFormattedNumber(e.target.value);
    const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
    e.target.value = formatted;
    // 커서 위치 보정 (콤마 추가로 인한 이동)
    const newLen = formatted.length;
    const diff = newLen - oldLen;
    e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
  });

  // v3.3.2: BB 입력 실시간 저장
  bbInput.addEventListener('blur', saveSettings_);

  // Review 모드 VIRTUAL 설정 (v3.0.0: 전송 버튼 제거, 설정만 유지)
  document.getElementById('virtualSheetId').value=S.virtualSheetId;
  document.getElementById('saveVirtualBtn').onclick=saveVirtualSettings_;
  document.getElementById('virtualMsg').textContent= S.virtualSheetId ? `VIRTUAL 시트 저장됨` : 'VIRTUAL 시트ID를 설정하세요';

  // v3.8.0: 설정 버튼 클릭 시 설정 패널 토글
  document.getElementById('settingsBtn').onclick = () => {
    const panel = document.getElementById('settingsPanel');
    const isHidden = panel.style.display === 'none';
    panel.style.display = isHidden ? 'block' : 'none';
    vibrate(HAPTIC.LIGHT);
  };

  updateLoading(1, 39, `테이블 드롭다운 (${S.tables.length}개)`);

  // v3.3.2: 데이터 로딩 검증
  console.log('[DATA] 테이블 수:', S.tables.length);
  console.log('[DATA] Roster 키:', Object.keys(S.roster).length);

  const sel=document.getElementById('tableSel');
  // v2.9.0: keyplayer 테이블 강조 표시 (v3.3.2: placeholder 간소화)
  sel.innerHTML = `<option value="">테이블</option>${S.tables.map(t => {
    const players = S.roster[t] || [];
    const keyplayerCount = players.filter(p => p.keyplayer === true).length;
    const isKeyplayer = keyplayerCount > 0;

    // ⭐ 아이콘 + keyplayer 수 표시
    const label = isKeyplayer
      ? `⭐ Table ${t} (${keyplayerCount} Key)`
      : `Table ${t}`;
    const className = isKeyplayer ? 'keyplayer-option' : '';

    return `<option value="${t}" class="${className}">${label}</option>`;
  }).join('')}`;
  sel.onchange=onTableChange;

  console.log('[DATA] 드롭다운 옵션 수:', sel.options.length);

  const streetSel=document.getElementById('streetStart');
  streetSel.onchange=e=>{ S.startStreetInit=e.target.value; S.curStreet=S.startStreetInit; resetHandState(false); renderAll(); };

  document.getElementById('btnSeat').onchange=e=>{S.btnSeat=toInt(e.target.value); buildTurnOrder(); renderAll();};

  // v3.3.0: prePot 포맷팅
  const prePotInput = document.getElementById('prePot');
  prePotInput.addEventListener('input', e => {
    const cursorPos = e.target.selectionStart;
    const oldLen = e.target.value.length;
    const cleaned = parseFormattedNumber(e.target.value);
    const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
    e.target.value = formatted;
    S.prePot = cleaned;
    S.pot = S.prePot + sumObj(S.contrib);
    renderPot();
    // 커서 위치 보정
    const newLen = formatted.length;
    const diff = newLen - oldLen;
    e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
  });
  updateLoading(1, 40, '테이블 초기화 완료');

  updateLoading(2, 45, 'handNo 입력 필드');
  // v3.3.0: handNo 입력 필드 - 자동 채움 + 수동 수정 가능
  const handNoInput = document.getElementById('handNo');
  handNoInput.oninput = e => {
    const val = e.target.value;
    if (val && val.trim() !== '') {
      S.nextHandNo = toInt(val); // 수동 수정 시 nextHandNo 동기화
    }
  };

  // Step 2: UI 컴포넌트 준비 (40% → 60%)
  updateLoading(2, 50, 'UI 컴포넌트 완료');

  // Step 3: 이벤트 리스너 등록 (60% → 75%)
  updateLoading(3, 60, 'Undo/Commit 버튼');

  document.getElementById('undoBtn').onclick=undoOnce;
  document.getElementById('commitBtn').onclick=commitHand;
  document.getElementById('newHandBtn').onclick=()=>resetHandState(true);

  updateLoading(3, 65, 'Review 모드 버튼');
  document.getElementById('refreshList').onclick=()=>loadList(true);
  document.getElementById('modeRecord').onclick=()=>setMode('record');
  document.getElementById('modeReview').onclick=()=>setMode('review');

  updateLoading(3, 70, '무한 스크롤 등록');
  // v1.2.0: 무한 스크롤
  document.getElementById('list').addEventListener('scroll', e=>{
    const el=e.target; if(el.scrollHeight-el.scrollTop-el.clientHeight<100) loadList(false);
  });

  updateLoading(3, 75, '이벤트 리스너 완료');

  // Step 4: 화면 렌더링 (75% → 90%)
  updateLoading(4, 80, 'Record 모드 설정');

  setMode('record');
  // v3.3.2: 보드 UI 지연 생성 (Lazy Loading - 사용 시 생성)
  document.getElementById('streetStart').value=S.startStreetInit;

  updateLoading(4, 85, '화면 렌더링');
  renderAll();
  // v3.3.2: Review 리스트 지연 로딩 (모드 전환 시 로딩)

  updateLoading(4, 90, '렌더링 완료');

  updateLoading(5, 92, '다음 핸드 번호 조회 중');
  // v3.3.0: 앱 시작 시 다음 핸드 번호 조회
  // v3.3.2: 비동기 완료 후 로딩 숨김
  initNextHandNo(() => {
    // Step 5: 완료 (90% → 100%)
    updateLoading(5, 100, '초기화 완료');

    // v3.3.2: 데이터 검증 완료 (핵심 설정이 항상 표시되므로 자동 열기 불필요)

    setTimeout(hideLoading, 300);
  });
}

/* ===== v3.3.0: Auto Hand Number ===== */
function initNextHandNo(callback) {
  updateLoading(5, 93, 'getNextHandNo API 호출');
  google.script.run
    .withSuccessHandler(num => {
      updateLoading(5, 97, `다음 핸드 #${num} 확인`);
      S.nextHandNo = num;
      updateHandNoDisplay();
      if(callback) callback(); // v3.3.2: 완료 콜백
    })
    .withFailureHandler(err => {
      console.error('getNextHandNo failed:', err);
      updateLoading(5, 97, 'fallback 핸드 #1');
      S.nextHandNo = 1; // fallback
      updateHandNoDisplay();
      if(callback) callback(); // v3.3.2: 실패해도 로딩 종료
    })
    .getNextHandNo();
}

function updateHandNoDisplay() {
  const input = document.getElementById('handNo');
  if (input) {
    input.value = S.nextHandNo;
    input.placeholder = `자동: ${S.nextHandNo}`;
  }
}

function saveSettings_(){
  // v3.3.0: 포맷팅된 입력값 파싱
  S.bbValue = parseFormattedNumber(document.getElementById('bbInput').value||'0');
  localStorage.setItem('phl_bbSize', S.bbValue);
  console.log('[SAVE] BB 저장:', S.bbValue);
}

function saveVirtualSettings_(){
  S.virtualSheetId = (document.getElementById('virtualSheetId').value||'').trim();
  localStorage.setItem('phl_virtualSheetId', S.virtualSheetId);
  document.getElementById('virtualMsg').textContent='저장됨';
  setTimeout(()=>document.getElementById('virtualMsg').textContent='',1500);
}

function setMode(m){
  const rec=document.getElementById('panelRecord'), rev=document.getElementById('panelReview');
  const bR=document.getElementById('modeRecord'), bV=document.getElementById('modeReview');
  const footer=document.getElementById('recordFooter'); // v3.8.0: Footer 참조

  if(m==='record'){
    rec.classList.remove('hidden'); rev.classList.add('hidden'); bR.classList.add('btnPrimary'); bV.classList.remove('btnPrimary');
    footer.style.display='block'; // v3.8.0: Record 탭에서 Footer 표시
  }
  else{
    rev.classList.remove('hidden'); rec.classList.add('hidden'); bV.classList.add('btnPrimary'); bR.classList.remove('btnPrimary');
    footer.style.display='none'; // v3.8.0: Review 탭에서 Footer 숨김
    // v3.3.2: 첫 Review 모드 전환 시에만 리스트 로드
    if(!reviewState.loaded){
      console.log('[LAZY] Review 리스트 첫 전환 시 로딩');
      loadList(true);
      reviewState.loaded = true;
    }
  }
}

/* ===== 테이블 변경 ===== */
function onTableChange(e){
  S.curTable=e.target.value||null;
  const arr=(S.roster[S.curTable]||[]).slice().sort((a,b)=>a.seat-b.seat);
  S.seats=arr.map(x=>({seat:toInt(x.seat), name:x.player, nation:x.nation, chips:x.chips, keyplayer:x.keyplayer}));
  S.activeSeatMap={}; S.seats.forEach(s=>S.activeSeatMap[s.seat]=true);
  S.folded={}; S.allin={}; S.stacks={};
  const btnDefault=toInt(S.cfg[S.curTable]?.btn_seat)||'';
  const btnSel=document.getElementById('btnSeat');
  // v2.4.0: BTN 드롭다운에 keyplayer ⭐ 표시
  btnSel.innerHTML=`<option value="">BTN 선택</option>${S.seats.map(s=>{
    const rosterEntry=(S.roster[S.curTable]||[]).find(r=>toInt(r.seat)===s.seat);
    const isKey=rosterEntry && rosterEntry.keyplayer;
    return `<option value="${s.seat}" ${s.seat==btnDefault?'selected':''}>${isKey?'⭐ ':''}${seatShort(s.seat,s.name)}</option>`;
  }).join('')}`;
  S.btnSeat=btnDefault||null; S.handNo=''; document.getElementById('handNo').value='';
  S.curStreet=S.startStreetInit; resetHandState(false); renderAll();
}

/* ===== 핸드 상태 ===== */
function resetHandState(clearInputs){
  S.contrib={}; S.actions=[]; S.nextSeq=1; S.board=[]; S.holes={};
  S.pot=S.prePot; S.toCall=0; S.allin={}; S.folded={}; S.acted=new Set();
  S.curStreet=S.startStreetInit; buildTurnOrder(); renderAll();
  if(clearInputs){
    document.getElementById('commitMsg').textContent='새 핸드 시작';
    // v3.3.0: 새 핸드 시작 시 hand_no 표시 업데이트
    updateHandNoDisplay();
  }
}

function buildTurnOrder(){
  const active=S.seats.map(s=>toInt(s.seat)).filter(seat=>S.activeSeatMap[seat]).sort((a,b)=>a-b);
  S.order=[]; if(!active.length){S.actorIdx=0; return;}
  const btn=toInt(S.btnSeat);
  if(S.curStreet!=='PREFLOP'){
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    const rotated=active.slice(start).concat(active.slice(0,start));
    const filtered=rotated.filter(v=>v!==btn); if(active.includes(btn)) filtered.push(btn);
    S.order=filtered;
  }else{
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    S.order=active.slice(start).concat(active.slice(0,start));
  }
  S.actorIdx=0; skipInvalidActors();
}

function skipInvalidActors(){
  if(S.order.length===0) return;
  let guard=0;
  while(guard<50){
    const seat=S.order[S.actorIdx%S.order.length];
    if(!S.activeSeatMap[seat] || S.allin[seat] || S.folded[seat]){ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; continue; }
    break;
  }
}

/* ===== 렌더 ===== */
function renderAll(){
  // v2.6.0: requestAnimationFrame으로 렌더링 최적화
  requestAnimationFrame(()=>{
    renderSeatToggles(); renderStackGrid(); renderActionPad(); renderTurnSeat(); renderPot(); renderFeed();
    document.getElementById('curStreetTag').textContent=S.curStreet;
    updateBoardDisplay();
  });
}

function seatShort(seat,name){
  const n=String(name||'').trim(); if(!n) return `#${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `#${seat} ${init}${last}`;
}
function seatNameOnly(seat,name){
  const n=String(name||'').trim(); if(!n) return `Seat ${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `${init}${last}`;
}

function renderSeatToggles(){
  const box=document.getElementById('seatsRow');
  if(!S.seats.length){box.innerHTML='<span class="muted small">테이블 선택</span>'; return;}
  box.innerHTML='';
  S.seats.forEach(s=>{
    const el=document.createElement('div');
    const rosterEntry=(S.roster[S.curTable]||[]).find(r=>toInt(r.seat)===s.seat);
    const isKey=rosterEntry && rosterEntry.keyplayer;
    const isActive=S.activeSeatMap[s.seat];
    // v3.3.2: 반응형 Pills (최소 크기, flex 자동 배치)
    el.className='pill '+(isKey && isActive?'keyplayer ':'')+(isActive?'active':'');
    el.style.minWidth='44px';
    el.style.flex='0 1 auto';
    el.textContent=(isKey?'⭐':'')+s.seat;
    el.title=(isKey?'⭐ ':'')+(s.name || 'Seat '+s.seat);
    el.onclick=()=>{ if(S.actions.length>0) return; S.activeSeatMap[s.seat]=!S.activeSeatMap[s.seat]; buildTurnOrder(); renderAll(); };
    box.appendChild(el);
  });
}

function renderStackGrid(){
  const grid=document.getElementById('stackGrid'); grid.innerHTML='';
  S.seats.filter(s=>S.activeSeatMap[s.seat]).forEach(s=>{
    const [c1,c2]=(S.holes[s.seat]||['','']);
    const wrap=document.createElement('div'); wrap.className='seatCard';
    // v3.3.0: stack 값 포맷팅
    const stackVal = S.stacks[s.seat];
    const displayVal = stackVal ? formatNumber(stackVal) : '';
    wrap.innerHTML = `
      <div class="small"><span class="playerName">${seatNameOnly(s.seat,s.name)}</span></div>
      <div class="row">
        <input type="text" inputmode="numeric" class="stack-input" data-seat="${s.seat}" placeholder="stack(선택)" value="${displayVal}" />
      </div>
      <div class="row small" style="margin-top:6px">
        <span class="muted">홀카드:</span>
        <span class="holeBadge">
          <span class="badge click" onclick="openHoleOverlay(${s.seat})">${prettyCard(c1)||'Card1'}/${prettyCard(c2)||'Card2'}</span>
          <button type="button" onclick="clearHole(${s.seat})">지우기</button>
        </span>
      </div>`;
    grid.appendChild(wrap);

    // v3.3.0: stack 입력 포맷팅 이벤트
    const input = wrap.querySelector('.stack-input');
    input.addEventListener('input', e => {
      const seat = toInt(e.target.dataset.seat);
      const cursorPos = e.target.selectionStart;
      const oldLen = e.target.value.length;
      const cleaned = parseFormattedNumber(e.target.value);
      const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
      e.target.value = formatted;
      S.stacks[seat] = cleaned;
      // 커서 위치 보정
      const newLen = formatted.length;
      const diff = newLen - oldLen;
      e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
      // v3.3.2: 스택 요약 업데이트
      updateStackSummary();
    });
  });
  // v3.3.2: 스택 그리드 렌더 후 요약 업데이트
  updateStackSummary();
}
window.S_setStack=(seat,v)=>{ S.stacks[seat]=parseFormattedNumber(v); };

function renderActionPad(){
  const pad=document.getElementById('actionPad'); pad.innerHTML='';
  const seat=currentActorSeat();
  if(!seat) return; // v3.3.2: 대기 버튼 제거 (액션 없으면 비움)
  const hasToCall=S.toCall>0;
  (hasToCall?['CALL','RAISE','FOLD','ALLIN']:['CHECK','BET','FOLD','ALLIN']).forEach(kind=>{
    const el=document.createElement('button'); el.type='button'; el.textContent=kind; el.onclick=()=>onAction(kind,seat); pad.appendChild(el);
  });
}
function renderTurnSeat(){ document.getElementById('turnSeat').textContent=currentActorSeat()?('Seat '+currentActorSeat()):'-'; }
function renderPot(){
  // v3.3.0: 숫자 포맷팅 적용
  document.getElementById('toCall').textContent=formatNumber(S.toCall);
  document.getElementById('pot').textContent=formatNumber(S.pot);
}
function currentActorSeat(){ if(S.order.length===0) return null; return S.order[S.actorIdx%S.order.length]; }

function renderFeed(){
  const box=document.getElementById('actionFeed');
  if(!S.actions.length){ box.innerHTML='<span class="muted">아직 액션 없음</span>'; return; }
  box.innerHTML=S.actions.map(a=>{
    const nm = seatNameOnly(a.seat, getSeatName(a.seat));
    return `#${a.seq} · ${a.street} · ${nm} · ${a.action}${a.amount_input?(' '+a.amount_input):''} → toCall ${a.to_call_after} · pot ${a.pot_after}`;
  }).join('<br/>');
  box.scrollTop=box.scrollHeight;
}

/* ===== 액션 ===== */
function onAction(kind,seat){
  if(kind==='FOLD'){ S.folded[seat]=true; applyAction({seat,action:'FOLD',amt:0}); return; }
  if(kind==='CHECK'){ if(S.toCall>0) return; applyAction({seat,action:'CHECK',amt:0}); return; }
  if(kind==='CALL'){ const need=Math.max(0, maxContribAll()- (S.contrib[seat]||0)); applyAction({seat,action:'CALL',amt:need}); return; }
  if(kind==='BET'||kind==='RAISE'||kind==='ALLIN'){
    let def='';
    if(kind==='ALLIN' && S.stacks[seat]!=null){
      const remain = Math.max(0, S.stacks[seat] - (S.contrib[seat]||0)); def = String(remain);
    }
    const val=prompt(`금액 입력 (${kind})`, def); if(val===null) return;
    applyAction({seat,action:(kind==='ALLIN')?'ALLIN':kind,amt:toInt(val)}); return;
  }
}

function applyAction({seat,action,amt}){
  const prev=S.contrib[seat]||0; S.contrib[seat]=prev+(toInt(amt)||0);
  if(action==='ALLIN') S.allin[seat]=true;
  S.pot=S.prePot+sumObj(S.contrib);
  if(action==='BET'||action==='RAISE'||action==='ALLIN'){ S.acted=new Set([seat]); }
  else if(action==='CHECK'||action==='CALL'){ S.acted.add(seat); }
  computeToCall();
  S.actions.push({seq:S.nextSeq++,street:S.curStreet,seat,action,amount_input:toInt(amt)||0,to_call_after:S.toCall,contrib_after_seat:S.contrib[seat],pot_after:S.pot});
  advanceActor(); renderAll();
  if(isStreetComplete()){
    const nxt=nextStreet(S.curStreet);
    if(nxt){ S.curStreet=nxt; S.acted=new Set(); computeToCall(); buildTurnOrder(); renderAll(); }
  }
}

/* === toCall === */
function maxContribAll(){
  const seats=S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.folded[seat]);
  let m=0; for(const s of seats){ m=Math.max(m, S.contrib[s]||0); } return m;
}
function computeToCall(){
  const maxC=maxContribAll(); let maxNeed=0;
  for(const s of aliveNonAllin()){
    const need=Math.max(0, maxC-(S.contrib[s]||0)); if(need>maxNeed) maxNeed=need;
  }
  S.toCall=maxNeed;
}
function aliveNonAllin(){ return S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.allin[seat] && !S.folded[seat]); }
function advanceActor(){ if(S.order.length===0) return; let guard=0; do{ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; } while(guard<50 && (!S.activeSeatMap[currentActorSeat()] || S.allin[currentActorSeat()] || S.folded[currentActorSeat()])); }
function isStreetComplete(){ const alive=aliveNonAllin(); if(alive.length<=1) return true; const everyoneActed = S.acted && (S.acted.size>=alive.length); return (S.toCall===0 && everyoneActed); }
function nextStreet(st){ if(st==='PREFLOP') return 'FLOP'; if(st==='FLOP') return 'TURN'; if(st==='TURN') return 'RIVER'; return null; }
function undoOnce(){
  if(S.actions.length===0) return;
  const last=S.actions.pop(); S.nextSeq--;
  S.contrib[last.seat]=(S.contrib[last.seat]||0)-(toInt(last.amount_input)||0);
  if(S.contrib[last.seat]<0) S.contrib[last.seat]=0;
  if(last.action==='ALLIN') S.allin[last.seat]=false;
  if(last.action==='FOLD') S.folded[last.seat]=false;
  S.curStreet = S.actions.length ? S.actions[S.actions.length-1].street : S.startStreetInit;
  S.pot=S.prePot+sumObj(S.contrib); computeToCall();
  S.actorIdx=Math.max(0,S.actorIdx-1)%((S.order.length)||1);
  S.acted=new Set(S.actions.filter(a=>a.street===S.curStreet).map(a=>a.seat));
  buildTurnOrder(); renderAll();
}

/* ===== 카드 UI ===== */
function buildBoardUI(containerId, handler){
  // v3.3.2: DocumentFragment로 한번에 DOM 추가 (리플로우 최소화)
  const box=document.getElementById(containerId); box.innerHTML='';
  const fragment = document.createDocumentFragment();

  SUITS.forEach(s=>{
    const col=document.createElement('div'); col.className='suitCol';
    RANKS.forEach(r=>{
      const c=r+s; const el=document.createElement('div'); el.className='card';
      el.textContent=prettyCard(c);
      // v2.5.0: touchstart 즉시 반응 + 햅틱
      el.addEventListener('touchstart', (e)=>{e.preventDefault(); vibrate(HAPTIC.LIGHT); handler(c,el);}, {passive:false});
      el.onclick=()=>handler(c,el);
      col.appendChild(el);
    });
    fragment.appendChild(col);
  });

  box.appendChild(fragment); // 단일 리플로우
}
function prettyCard(cs){
  if(!cs) return ''; const cc=cardCode(cs); const suit=cc.slice(-1), r=cc.slice(0,-1);
  const map={s:'♠',h:'♥',d:'♦',c:'♣'}; return r+map[suit];
}
function toggleBoardCard(card,el){
  const i=S.board.indexOf(card);
  if(i>=0){
    S.board.splice(i,1);
    el.classList.remove('sel');
    vibrate(HAPTIC.LIGHT);
    updateBoardDisplay(); // v3.3.2
    return;
  }
  if(S.board.length>=5) return;
  S.board.push(card);
  el.classList.add('sel');
  vibrate(HAPTIC.MEDIUM);
  updateBoardDisplay(); // v3.3.2
}
function syncBoardSelection(id){
  const box=document.getElementById(id); if(!box) return;
  [...box.querySelectorAll('.card')].forEach(dom=>{
    const c=labelToCode(dom.textContent);
    if(S.board.includes(c)) dom.classList.add('sel'); else dom.classList.remove('sel');
  });
}
function labelToCode(label){
  const r=label.replace(/[♠♥♦♣]/,'').trim();
  const sMap={'♠':'s','♥':'h','♦':'d','♣':'c'}; const sym=label.slice(-1);
  return r + (sMap[sym]||'');
}

/* 홀카드 오버레이(2장 연속 선택) — 보드중복 차단(단방향) */
function openHoleOverlay(seat){
  S.holePickSeat=seat;

  // v3.3.2: 홀카드 핸들러로 재빌드 (보드와 분리)
  console.log('[FIX] 홀카드 UI - pickCardOverlay 핸들러 연결');
  buildBoardUI('boardRowOverlay', pickCardOverlay);

  document.getElementById('ovTitle').textContent=`${seatNameOnly(seat, getSeatName(seat))} · 홀카드`;
  updateOvCount_(seat);
  // v2.5.0: Bottom Sheet 애니메이션
  const ov=document.getElementById('overlay');
  ov.style.display='flex';
  setTimeout(()=>ov.classList.add('show'),10);
  vibrate(HAPTIC.MEDIUM);

  // 홀카드 선택 상태 동기화
  syncHoleSelection(seat);
}

function syncHoleSelection(seat){
  const arr = S.holes[seat] || ['', ''];
  const cards = document.querySelectorAll('#boardRowOverlay .card');
  cards.forEach(el => {
    const text = el.textContent;
    const matched = [...SUITS].find(s => [...RANKS].find(r => prettyCard(r+s) === text));
    if(!matched) return;

    const card = [...RANKS].find(r => [...SUITS].find(s => prettyCard(r+s) === text));
    const fullCard = card ? card + matched : null;

    if(arr.includes(fullCard)){
      el.classList.add('active');
    }else{
      el.classList.remove('active');
    }
  });
}
function pickCardOverlay(card,el){
  if(!S.holePickSeat) return;
  // 보드에 이미 있는 카드는 홀카드에서 선택 불가(요청사항 v1.1)
  if(S.board.includes(card)){ vibrate(HAPTIC.STRONG); return; }

  const seat=S.holePickSeat;
  const arr=S.holes[seat]||['',''];
  const existsIdx = arr.indexOf(card);
  if(existsIdx>=0){ arr[existsIdx]=''; vibrate(HAPTIC.LIGHT); }
  else{
    if(!arr[0]) arr[0]=card;
    else if(!arr[1]) arr[1]=card;
    else { arr[0]=arr[1]; arr[1]=card; }
    vibrate(HAPTIC.MEDIUM);
  }
  S.holes[seat]=arr; renderStackGrid(); updateOvCount_(seat);
  if(arr[0] && arr[1]){ setTimeout(closeOverlay,200); }
}
function updateOvCount_(seat){
  const arr=S.holes[seat]||['','']; const n=(arr[0]?1:0)+(arr[1]?1:0);
  document.getElementById('ovCount').textContent=` · 선택 ${n}/2`;
}
function clearHole(seat){ S.holes[seat]=['','']; renderStackGrid(); vibrate(HAPTIC.LIGHT); }
function closeOverlay(){
  // v2.5.0: Bottom Sheet 닫기 애니메이션
  const ov=document.getElementById('overlay');
  ov.classList.remove('show');
  setTimeout(()=>ov.style.display='none',300);
  S.holePickSeat=null;
  vibrate(HAPTIC.LIGHT);
}

/* ===== 커밋/리뷰 ===== */
function commitHand(){
  perfStart('commit');
  saveSettings_();

  // v3.3.0: 자동 hand_no 사용 (수동 입력 시 입력값 우선)
  const handNoInput = document.getElementById('handNo');
  const manualHandNo = handNoInput.value ? toInt(handNoInput.value) : 0;
  const handNo = manualHandNo > 0 ? manualHandNo : S.nextHandNo;

  // v3.9.0: 로컬 PC 시간으로 저장 (VIRTUAL B열 매칭용)
  const now = new Date();
  const localISO = now.toISOString(); // UTC 시간 (서버 저장용)
  const localHHMM = String(now.getHours()).padStart(2,'0') + ':' + String(now.getMinutes()).padStart(2,'0'); // 로컬 HH:mm

  const payload={
    client_uuid: uuid(),
    event_id:'',
    table_id:S.curTable||'',
    hand_no: handNo,
    start_street:S.startStreetInit,
    started_at:localISO,
    started_at_local:localHHMM, // v3.9.0: 로컬 HH:mm (VIRTUAL B열 매칭용)
    ended_at:'',
    btn_seat:S.btnSeat||'',
    board:getBoardObjectForSave(),
    pre_pot:S.prePot||'',
    winner_seat:'',
    pot_final:'',
    actions:S.actions.map(x=>Object.assign({},x)),
    holes:S.holes,
    stack_snapshot:S.stacks
  };
  const msg=document.getElementById('commitMsg');
  const btn=document.getElementById('commitBtn'); btn.disabled=true;

  // v3.6.0: 스마트 로딩 (compact 모드 + 햅틱)
  showLoading('핸드 데이터 저장 중...', { mode: 'compact', percent: 50, haptic: true });

  // v2.3.0: Record는 HANDS/ACTIONS만 저장 (VIRTUAL 자동 전송 제거)
  google.script.run
    .withSuccessHandler(res=>{
      perfEnd('commit');
      hideLoading(true); // 햅틱 자동 트리거
      msg.textContent=`완료: #${res.hand_no||'-'} (${res.hand_id})`;
      btn.disabled=false;

      // v3.3.0: 커밋 후 다음 핸드 번호 증가
      S.nextHandNo++;
      updateHandNoDisplay();

      resetHandState(true); loadList();
    })
    .withFailureHandler(err=>{
      perfEnd('commit');
      hideLoading(false); // 실패 시 햅틱 없음
      msg.textContent='오류: '+(err.message||err);
      btn.disabled=false;
      vibrate(HAPTIC.STRONG);
    })
    .saveHand(payload);
}

/* v3.0.0: 핸드 상세에서 VIRTUAL 전송 (복수 플레이어 선택 + 탈락 + 스택 수정) */
function sendCurrentHandToVirtual(){
  saveVirtualSettings_();
  if(!S.virtualSheetId){ alert('VIRTUAL 시트 ID를 먼저 설정하세요'); return; }

  // v3.8.0: hand_id 검증 강화
  const handId = reviewState.selectedId;
  console.log('[DEBUG] sendCurrentHandToVirtual - reviewState.selectedId:', handId, 'type:', typeof handId);

  if(!handId || String(handId).trim() === ''){
    alert('핸드가 선택되지 않았습니다.\n\nReview 리스트에서 핸드를 먼저 선택하세요.');
    console.error('[ERROR] hand_id 없음 - reviewState:', reviewState);
    return;
  }

  // v3.6.3: 중복 전송 방지
  if(S.sentHandIds.has(reviewState.selectedId)){
    alert('⚠️ 이미 전송한 핸드입니다.\n\n같은 핸드를 다시 전송하려면 페이지를 새로고침하세요.');
    return;
  }

  // 1. 선택된 플레이어 seat 배열 (자막에 표시할 플레이어)
  const selectedSeats = Array.from(document.querySelectorAll('.player-select-chk:checked'))
    .map(chk => chk.value);

  if(selectedSeats.length === 0){
    alert('자막에 표시할 플레이어를 최소 1명 이상 선택하세요');
    return;
  }

  // 2. 탈락 플레이어 seat 배열
  const eliminatedSeats = Array.from(document.querySelectorAll('.eliminated-chk:checked'))
    .map(chk => chk.dataset.seat);

  // 3. 수정된 스택 값 수집 (v3.3.0: 포맷팅된 값 파싱)
  const stackOverrides = {};
  document.querySelectorAll('.stack-override-input').forEach(input => {
    const seat = input.dataset.seat;
    const value = parseFormattedNumber(input.value);
    stackOverrides[seat] = value;
  });

  // 4. 수정된 BB 값 (v3.3.0: 포맷팅된 값 파싱)
  const bbOverride = parseFormattedNumber(document.getElementById('bbOverrideInput').value);

  // 5. payload 구성
  const payload = {
    selectedSeats: selectedSeats,
    eliminatedSeats: eliminatedSeats,
    stackOverrides: stackOverrides,
    bbOverride: bbOverride
  };

  console.log('[VIRTUAL] 전송 payload:', payload);

  const btn = document.getElementById('sendToVirtualDetailBtn');
  const msg = document.getElementById('virtualDetailMsg');

  btn.disabled = true;
  msg.textContent = '';

  // v3.6.0: 스마트 로딩 (compact 모드, 햅틱 없음)
  showLoading('VIRTUAL 시트 전송 중...', { mode: 'compact', percent: 50, haptic: false });

  google.script.run
    .withSuccessHandler(res=>{
      console.log('VIRTUAL 전송 응답 (상세뷰):', res);
      console.log('  res.success:', res?.success);
      console.log('  res.reason:', res?.reason);
      console.log('  res.row:', res?.row);
      console.log('  res 전체 JSON:', JSON.stringify(res, null, 2));
      hideLoading(true);
      btn.disabled = false;

      if(res && res.success){
        // v3.6.3: 전송 성공 시 hand_id 추가
        S.sentHandIds.add(reviewState.selectedId);

        btn.textContent = '✅ 전송 완료';
        btn.style.backgroundColor = '#22c55e';
        btn.style.borderColor = '#22c55e';

        // v3.9.16: 시간 매칭 정보 표시
        const matchInfo = res.matchedTime
          ? ` | 매칭: ${res.matchedTime}`
          : '';
        msg.textContent = `✅ 전송 성공! Row ${res.row}${matchInfo} (선택: ${selectedSeats.length}명)`;
        msg.style.color = '#22c55e';
        vibrate(HAPTIC.MEDIUM); // 선택 작업 햅틱

        // 리스트 항목에도 시각적 표시
        const selectedCard = document.querySelector('#list .seatCard.selected');
        if(selectedCard && !selectedCard.dataset.sent){
          selectedCard.style.borderColor = '#22c55e';
          selectedCard.dataset.sent = 'true';
        }
      }else{
        // v3.8.0: 실패 응답 상세 로깅
        console.error('❌ [VIRTUAL] 전송 실패');
        console.error('  res 전체:', JSON.stringify(res, null, 2));
        console.error('  res.success:', res?.success);
        console.error('  res.reason:', res?.reason);
        console.error('  res.row:', res?.row);

        // 🔍 디버깅: B열 스캔 결과 출력
        if(res?.debug){
          console.error('🔍 [DEBUG] B열 매칭 실패 상세:');
          console.error('  찾으려는 시간:', res.debug.target);
          console.error('  스캔된 행들 (최근 20개):');
          (res.debug.scanned || []).forEach((info, idx) => {
            console.error(`    ${idx + 1}. ${info}`);
          });
        }

        btn.textContent = '📤 VIRTUAL 전송';

        // 상세 에러 메시지 구성
        let errorMsg = '전송 실패';
        if(res?.reason === 'no-match'){
          errorMsg = '❌ 매칭 실패: VIRTUAL 시트 B열에서 핸드번호를 찾을 수 없습니다.\n\n→ Apps Script 로그를 확인하세요 (실행 > 로그)';
        }else if(res?.reason){
          errorMsg = `❌ 전송 실패: ${res.reason}`;
        }else{
          errorMsg = `❌ 전송 실패: 알 수 없는 오류 (응답: ${JSON.stringify(res)})`;
        }

        msg.textContent = errorMsg;
        msg.style.color = '#ef4444';
        alert(errorMsg); // 사용자에게 명확한 피드백
      }

      setTimeout(()=>{msg.textContent=''; msg.style.color='';}, 5000);
    })
    .withFailureHandler(err=>{
      hideLoading(false); // 실패 시 햅틱 없음
      btn.disabled = false;
      btn.textContent = '📤 VIRTUAL 전송';
      msg.textContent = `❌ 오류: ${err.message||err}`;
      msg.style.color = '#ef4444';
      setTimeout(()=>{msg.textContent=''; msg.style.color='';}, 5000);
    })
    .sendHandToVirtual(reviewState.selectedId, S.virtualSheetId, payload);
}
function getBoardObjectForSave(){
  const b=[...S.board]; // [f1,f2,f3,turn,river]
  return {f1:b[0]||'',f2:b[1]||'',f3:b[2]||'',turn:b[3]||'',river:b[4]||''};
}

/* === Review 상태 관리 (v1.2.0) === */
// v3.3.2: Review 리스트 지연 로딩을 위한 플래그 추가
const reviewState={page:1,size:10,total:0,loading:false,hasMore:true,selectedId:null,loaded:false};

function loadList(reset){
  if(reset){ reviewState.page=1; reviewState.hasMore=true; reviewState.total=0; }
  if(reviewState.loading||!reviewState.hasMore) return;
  reviewState.loading=true;
  const box=document.getElementById('list');

  // v3.6.0: 스마트 로딩 (compact 모드, 리스트 조회)
  if(reset) showLoading('핸드 리스트 조회 중...', { mode: 'compact', percent: 50, haptic: false });

  google.script.run.withSuccessHandler(data=>{
    reviewState.loading=false;
    if(reset) hideLoading(true);

    if(data.error){ box.innerHTML=`<div class="small" style="color:#ffbdbd">오류: ${data.error}</div>`; return; }
    reviewState.total=data.total;
    document.getElementById('listInfo').textContent=`총 ${reviewState.total}건 (${reviewState.page}페이지)`;
    if(reset) box.innerHTML='';
    if(!data.items||data.items.length===0){ reviewState.hasMore=false; return; }
    data.items.forEach(it=>box.appendChild(createListItem(it)));
    reviewState.page++;
    reviewState.hasMore=(box.children.length<reviewState.total);

    // v3.3.3: 첫 로딩 시 최신 핸드 자동 선택
    if(reset && data.items.length > 0){
      const firstItem = data.items[0];
      const firstEl = box.querySelector(`[data-hand-id="${firstItem.hand_id}"]`);
      if(firstEl){
        console.log('[AUTO] 최신 핸드 자동 선택:', firstItem.hand_id);
        selectAndLoadDetail(firstItem.hand_id, firstEl);
      }
    }
  }).withFailureHandler(err=>{
    reviewState.loading=false;
    if(reset) hideLoading(false);
    box.innerHTML=`<div class="small" style="color:#ffbdbd">로드 오류: ${(err.message||err)}</div>`;
  }).queryHands({},{num:reviewState.page,size:reviewState.size});
}

function formatStartedAt(isoString){
  if(!isoString) return '-';
  try{
    const d = new Date(isoString);
    if(isNaN(d.getTime())) return isoString; // 파싱 실패 시 원본 반환

    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    const hh = String(d.getHours()).padStart(2, '0');
    const mm = String(d.getMinutes()).padStart(2, '0');

    return `${month}/${day} ${hh}:${mm}`;  // "01/18 15:51"
  }catch(e){
    return isoString; // 에러 시 원본 반환
  }
}

// v3.9.15: 로컬 시간 포맷팅 (HH:mm → MM/DD HH:mm)
function formatLocalTime(hhmmTime){
  if(!hhmmTime) return '-';
  const now = new Date();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  return `${month}/${day} ${hhmmTime}`;  // "10/19 00:23"
}

function createListItem(it){
  const div=document.createElement('div'); div.className='seatCard'; div.dataset.handId=it.hand_id;
  const arr=boardToArray(it.board||it)||[];
  const boardBadgesHTML=arr.slice(0,3).map(cs=>renderCardBadge(cs,'small')).join('')+(arr.length>3?'...':'');

  // v3.9.15: started_at_local 우선 사용
  const timeDisplay = it.started_at_local
    ? formatLocalTime(it.started_at_local)
    : formatStartedAt(it.started_at);

  div.innerHTML=`
    <div><b>#${it.hand_no||'-'}</b> · Table ${it.table_id||'-'} · BTN ${it.btn_seat||'-'} · <span class="badge">${it.start_street||'-'}</span></div>
    <div class="small muted">${timeDisplay}</div>
    <div class="boardSmall">${boardBadgesHTML||'<span class="muted">-</span>'}</div>`;
  div.onclick=()=>selectAndLoadDetail(it.hand_id,div);
  return div;
}

function selectAndLoadDetail(id,el){
  document.querySelectorAll('#list .seatCard').forEach(d=>d.classList.remove('selected'));
  el.classList.add('selected');
  reviewState.selectedId=id;
  loadDetail(id);
}

/* 상세 */
function loadDetail(id){
  const d = document.getElementById('detail');
  if (!id || String(id).trim() === '') { d.innerHTML = `<div class="small" style="color:#ffbdbd">잘못된 hand id</div>`; return; }

  // v3.6.0: 스마트 로딩 (150ms 작업 - 표시 안 될 확률 높음)
  showLoading('핸드 상세 조회 중...', { mode: 'compact', percent: 50, haptic: false });

  google.script.run
    .withSuccessHandler(x=>{
      hideLoading(true);
      try{
        if (!x) { d.innerHTML = `<div class="small" style="color:#ffbdbd">서버 응답 없음(undefined) · id=${id}</div>`; return; }
        if (x.error) { d.innerHTML = `<div class="small" style="color:#ffbdbd">오류: ${x.error} · id=${id}</div>`; return; }
        const head = (x.head && typeof x.head === 'object') ? x.head : {};
        const acts = Array.isArray(x.acts) ? x.acts : (Array.isArray(x.actions) ? x.actions : []);
        const stacks = safeJson_(head.stacks_json||{});
        if (!Object.keys(head).length) {
          const sample = JSON.stringify(x).slice(0,400);
          d.innerHTML = `<div class="small" style="color:#ffbdbd">형식 오류(빈 head) · id=${id}<br/><code>${sample}</code></div>`;
          return;
        }
        d.innerHTML = renderDetailContent(head, acts);
      }catch(err){
        const msg=(err && (err.message||err.toString()))||'unknown';
        d.innerHTML = `<div class="small" style="color:#ffbdbd">클라이언트 렌더 오류: ${msg} · id=${id}</div>`;
      }
    })
    .withFailureHandler(err=>{
      hideLoading(false);
      const msg = (err && (err.message || err.toString())) || 'unknown failure';
      d.innerHTML = `<div class="small" style="color:#ffbdbd">로드 실패: ${msg} · id=${id}</div>`;
    })
    .getHandDetail(id);
}

/* ===== Review 렌더 유틸 ===== */
function cardCode(cs){
  if (!cs) return '';
  if (typeof cs === 'string') return cs.trim();
  if (cs.card) return String(cs.card).trim();
  if (cs.rank && cs.suit){
    const r = String(cs.rank).toUpperCase().replace('10','T');
    const map={spade:'s',heart:'h',diamond:'d',club:'c','S':'s','H':'h','D':'d','C':'c'};
    const sRaw=String(cs.suit); const s=map[sRaw]||map[sRaw.toLowerCase()]||sRaw.toLowerCase();
    return r+s;
  }
  if (Array.isArray(cs) && cs.length>=2){
    const r=String(cs[0]).toUpperCase().replace('10','T');
    const s=String(cs[1]).toLowerCase(); return r+s;
  }
  return '';
}
function boardToArray(b){
  if(!b) return [];
  if(Array.isArray(b)) return b.map(cardCode).filter(Boolean);
  // 서버 응답 포맷: {f1,f2,f3,turn,river} 또는 {board_f1,board_f2,...}
  const keys=['f1','f2','f3','turn','river'].map(k=>cardCode(b[k])).filter(Boolean);
  if(keys.length) return keys;
  const keys2=['board_f1','board_f2','board_f3','board_turn','board_river'].map(k=>cardCode(b[k])).filter(Boolean);
  return keys2.length?keys2:(b.board?boardToArray(b.board):[]);
}
function boardBadges(b){
  const arr=boardToArray(b); if(!arr.length) return '<span class="muted">-</span>';
  return `<div style="display:flex;gap:10px;flex-wrap:wrap">${arr.map(cs=>renderCardBadge(cs)).join('')}</div>`;
}
function getSeatName(seat){
  const s = (S.roster[S.curTable]||[]).find(x=>toInt(x.seat)===toInt(seat));
  return s?.player || `Seat ${seat}`;
}
function seatNameOnlyFmt(seat){ return seatNameOnly(seat, getSeatName(seat)); }
function groupByStreet(acts){
  const g={PREFLOP:[],FLOP:[],TURN:[],RIVER:[]};
  (acts||[]).forEach(a=>{ const s=(a.street||'').toUpperCase(); if(g[s]) g[s].push(a); else g.RIVER.push(a); });
  return g;
}
function formatStreetSection(title,arr,tableId,idx){
  if(!arr||!arr.length) return '';
  // v3.8.0: Minimal 디자인 - 좌측 컬러바 + 금액 우측 고정
  const badges=arr.map(a=>{
    const fullName=getSeatNameByTable(tableId,a.seat);
    const name=seatNameOnly(a.seat,fullName);
    const amt=toInt(a.amount_input||0);
    const k=(a.action||'').toUpperCase();
    const actionClass=k==='CHECK'?'check':(k==='CALL'?'call':((k==='BET'||k==='RAISE'||k==='ALLIN')?'raise':'fold'));
    const amtDisplay=amt>0?`<div class="amount">${formatCompact(amt)}</div>`:'';
    return `<div class="actBadge ${actionClass}">
      <div class="left">
        <span class="name">${name}</span>
        <span class="action">${a.action||''}</span>
      </div>
      ${amtDisplay}
    </div>`;
  }).join('');
  const collapseId=`street_${idx}`;
  return `<div class="streetRow">
    <span class="streetTitle" onclick="toggleStreet('${collapseId}')">▼ ${title}(${arr.length})</span>
    <div id="${collapseId}" class="streetBadges">${badges}</div>
  </div>`;
}
/* === Review 상세 렌더링 헬퍼 (v3.1.0) === */
function renderCardBadge(cs,size='large'){
  const cc=cardCode(cs); if(!cc) return '';
  const suit=cc.slice(-1), r=cc.slice(0,-1);
  const sym=suit==='s'?'♠':suit==='h'?'♥':suit==='d'?'♦':'♣';
  const cl=suit==='s'?'cb-s':suit==='h'?'cb-h':suit==='d'?'cb-d':'cb-c';
  const sizeClass=size==='compact'?'cardBadgeSmall':(size==='small'?'cardBadgeSmall':'cardBadge');
  return `<span class="${sizeClass} ${cl}">${r}${sym}</span>`;
}

function toggleStreet(id){
  const el=document.getElementById(id);
  if(!el) return;
  if(el.style.display==='none'){
    el.style.display='inline';
    el.previousElementSibling.textContent=el.previousElementSibling.textContent.replace('▶','▼');
  }else{
    el.style.display='none';
    el.previousElementSibling.textContent=el.previousElementSibling.textContent.replace('▼','▶');
  }
}

function calculateFinalPot(head,acts){
  if(head.pot_final) return toInt(head.pot_final);
  let maxPot=0;
  (acts||[]).forEach(a=>{const val=toInt(a.pot_after); if(val>maxPot) maxPot=val;});
  return maxPot||toInt(head.pre_pot)||0;
}

function formatCompact(num){
  num=toInt(num);
  if(num>=1000000) return (num/1000000).toFixed(1)+'M';
  if(num>=1000){
    const k=num/1000;
    return (k%1===0?k.toFixed(0):k.toFixed(1))+'k';
  }
  return num.toString();
}

function formatPotWithBB(pot,bb){
  pot=toInt(pot);
  if(!bb||bb===0) return formatCompact(pot);
  const bbVal=(pot/bb).toFixed(1);
  return `${formatCompact(pot)}(${bbVal}BB)`;
}

function renderPotHeader(head,acts){
  const pot=calculateFinalPot(head,acts);
  const bb=toInt(localStorage.getItem('phl_bbSize')||0);
  const handIdShort=(head.hand_id||'').slice(0,8)+'...';
  const bbInfo=bb>0?` BB${formatCompact(bb)}`:'';

  // v3.8.0: 선누적팟 + 시작스트릿 추가
  const prePot=toInt(head.pre_pot||0);
  const prePotInfo=prePot>0?` · PRE:+${formatCompact(prePot)}`:'';
  const startStreet=(head.start_street||'').toUpperCase();
  const startInfo=startStreet&&startStreet!=='PREFLOP'?`START:${startStreet}`:'';
  const metaInfo=startInfo+prePotInfo;

  // v3.9.2: 시간 표시 추가
  // v3.9.15: started_at_local 우선 사용 (Cyprus 로컬 시간)
  const timeFormatted = head.started_at_local
    ? formatLocalTime(head.started_at_local)
    : formatStartedAt(head.started_at);

  return `<div class="potHeader">
    <div class="potHeader-top">
      <div><b>#${head.hand_no||'-'}</b> T${head.table_id||'-'} BTN${head.btn_seat||'-'}${bbInfo}</div>
      <div><b>${formatPotWithBB(pot,bb)}</b></div>
    </div>
    ${metaInfo?`<div class="potHeader-bottom">
      <span style="color:#64748b;font-size:0.65rem">${metaInfo}</span>
      <span style="color:#64748b;font-size:0.65rem">${timeFormatted}</span>
    </div>
    <div class="potHeader-bottom">
      <span style="color:#64748b;font-size:0.65rem">${handIdShort}</span>
    </div>`:`<div class="potHeader-bottom">
      <span style="color:#64748b;font-size:0.65rem">${timeFormatted}</span>
      <span style="color:#64748b;font-size:0.65rem">${handIdShort}</span>
    </div>`}
  </div>`;
}

function getSeatNameByTable(tableId,seat){
  const roster=S.roster[tableId]||[];
  const s=roster.find(x=>toInt(x.seat)===toInt(seat));
  return s?.player || `Seat ${seat}`;
}

function isKeyplayer(tableId,seat){
  const roster=S.roster[tableId]||[];
  const s=roster.find(x=>toInt(x.seat)===toInt(seat));
  return !!(s && s.keyplayer);
}

function renderPlayerRows(head){
  const stacks=safeJson_(head.stacks_json||'{}');
  const holes=safeJson_(head.holes_json||'{}');
  const btnSeat=toInt(head.btn_seat);
  const tableId=head.table_id;

  // v3.6.1: stacks_json이 비어있으면 holes_json에서 좌석 추출
  const stackSeats=Object.keys(stacks);
  const holeSeats=Object.keys(holes);
  const allSeats=[...new Set([...stackSeats,...holeSeats])].sort((a,b)=>toInt(a)-toInt(b));
  if(!allSeats.length) return '';

  const rows=allSeats.map(s=>{
    const seat=toInt(s);
    const fullName=getSeatNameByTable(tableId,seat);
    const name=seatNameOnly(seat,fullName);
    const pos=(seat===btnSeat)?' BTN':'';
    const isKey=isKeyplayer(tableId,seat);
    const keyIcon=isKey?'⭐':'';
    const holeCards=holes[s]||[];
    const holeHTML=(holeCards[0]&&holeCards[1])
      ?renderCardBadge(holeCards[0],'compact')+renderCardBadge(holeCards[1],'compact')
      :'<span class="muted" style="font-size:0.7rem">-</span>';
    const stack=stacks[s]?formatCompact(toInt(stacks[s])):'-';
    return `<div class="playerRow">
      <span class="playerSeat">${keyIcon}#${seat}</span>
      <span class="playerName">${name}${pos}</span>
      <span class="playerHole">${holeHTML}</span>
      <span class="playerStack">${stack}</span>
    </div>`;
  }).join('');

  return `<div class="playerSection">${rows}</div>`;
}

function renderPotFooter(head,acts){
  return '';
}

function renderDetailContent(head,acts){
  const b=head.board||head||{}; const g=groupByStreet(acts||[]);
  const tableId=head.table_id;
  const participants = extractParticipants(head, acts);
  const boardArr=boardToArray(b);

  return `${renderPotHeader(head,acts)}

    <div class="boardSection">
      ${boardArr.length>0?`<div style="display:flex;gap:3px;flex-wrap:wrap">${boardArr.map(cs=>renderCardBadge(cs,'compact')).join('')}</div>`:'<span class="muted" style="font-size:0.7rem">-</span>'}
    </div>

    ${renderPlayerRows(head)}

    <div class="sectionDivider"></div>

    ${formatStreetSection('PREFLOP',g.PREFLOP,tableId,0)}
    ${formatStreetSection('FLOP',g.FLOP,tableId,1)}
    ${formatStreetSection('TURN',g.TURN,tableId,2)}
    ${formatStreetSection('RIVER',g.RIVER,tableId,3)}

    ${renderPotFooter(head,acts)}

    ${renderVirtualSection(head, participants)}`;
}

function renderVirtualSection(head, participants){
  // v3.3.3: 핸드에 저장된 BB 우선 사용, 없으면 전역 설정값 사용
  const defaultBB = S.bbValue || 0;
  const handId = head ? head.hand_id : '';

  // v3.3.3: 세로 방향 레이아웃 (각 플레이어 별도 줄)
  const playerRows = participants.map(p => `
    <div style="display:flex; align-items:center; gap:6px; padding:4px 0; border-bottom:1px solid #1e293b;">
      <input type="checkbox" class="player-select-chk" value="${p.seat}" checked
             style="width:16px; height:16px; cursor:pointer; accent-color:#3b82f6; flex-shrink:0;">
      <span style="font-weight:600; min-width:80px; font-size:0.75rem;">${p.name}</span>
      <input type="text" inputmode="numeric" class="stack-override-input" data-seat="${p.seat}" value="${formatNumber(p.stack || 0)}" placeholder="스택"
             style="width:90px; padding:4px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.7rem;">
      <label style="display:flex; align-items:center; gap:3px; margin-left:auto;">
        <span style="color:#94a3b8; font-size:0.65rem;">탈락</span>
        <input type="checkbox" class="eliminated-chk" data-seat="${p.seat}"
               style="width:14px; height:14px; cursor:pointer; accent-color:#ef4444;">
      </label>
    </div>
  `).join('');

  return `
    <div style="margin-top:8px; padding:8px; background:#0e1322; border-radius:4px; border:1px solid #1e293b;">
      <div style="font-size:0.75rem; font-weight:600; color:#94a3b8; margin-bottom:8px;">📡 VIRTUAL 시트 전송</div>

      <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #1e293b;">
        <label style="display:flex; align-items:center; gap:6px;">
          <span style="color:#94a3b8; font-size:0.75rem; min-width:30px;">BB</span>
          <input type="text" inputmode="numeric" id="bbOverrideInput" value="${formatNumber(defaultBB)}" placeholder="1,000"
                 style="width:100px; padding:4px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.75rem;">
        </label>
      </div>

      <div style="margin-bottom:10px;">
        ${playerRows}
      </div>

      <button id="sendToVirtualDetailBtn" class="btnPrimary" onclick="sendCurrentHandToVirtual()"
              style="width:100%; padding:8px; font-size:0.75rem; font-weight:600;">
        📤 VIRTUAL 전송
      </button>

      <div id="virtualDetailMsg" style="margin-top:6px; font-size:0.7rem; text-align:center;"></div>
    </div>
  `;
}

/* ===== 참가자 추출 (핸드 상세 → 플레이어 목록 + 스택 데이터) ===== */
function extractParticipants(head, acts){
  // acts에서 seat 추출
  const seats = new Set();
  (acts||[]).forEach(a => {
    if(a.seat) seats.add(String(a.seat));
  });

  // holes_json에서도 추출 (액션 없이 폴드한 경우 대비)
  const holes = safeJson_(head.holes_json||'{}');
  Object.keys(holes||{}).forEach(seat => seats.add(String(seat)));

  // stacks_json에서 최종 스택 추출
  const stacks = safeJson_(head.stacks_json||'{}');

  // roster에서 이름 매칭
  const tableId = head.table_id;
  const roster = (S.roster && S.roster[tableId]) || [];

  return Array.from(seats).sort((a,b)=>toInt(a)-toInt(b)).map(seat => {
    const player = roster.find(p => String(p.seat) === String(seat));
    const stack = stacks[seat] ? toInt(stacks[seat]) : 0;

    return {
      seat: seat,
      name: player && player.player ? player.player : `Seat ${seat}`,
      stack: stack
    };
  });
}

/* ===== 유틸 ===== */
function sumObj(o){ return Object.values(o||{}).reduce((a,b)=>a+(toInt(b)||0),0); }
function toInt(v){ const n=parseInt(v,10); return isNaN(n)?0:n; }
function uuid(){ return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)); }
function safeJson_(s){ try{return typeof s==='string'?JSON.parse(s||'{}'):(s||{});}catch(e){return {}} }

/* v3.3.0: 숫자 포맷팅 (3자리마다 콤마) */
function formatNumber(num){
  const n = toInt(num);
  return n.toLocaleString('en-US');
}
function parseFormattedNumber(str){
  if(!str) return 0;
  const cleaned = String(str).replace(/,/g, '');
  return toInt(cleaned);
}

/* ===== v2.9.0: 테스트 함수 (브라우저 콘솔에서 실행) ===== */
function testKeyplayerSort() {
  console.log('=== v2.9.0 Keyplayer Sort Test ===');

  // Test 1: 키플레이어 2개 테이블
  const test1Tables = ['1', '15', '2', '23', '3'];
  const test1Roster = {
    '15': [{seat: 1, keyplayer: true}, {seat: 2, keyplayer: false}],
    '23': [{seat: 1, keyplayer: true}],
    '1': [{seat: 1, keyplayer: false}],
    '2': [{seat: 1, keyplayer: false}],
    '3': [{seat: 1, keyplayer: false}]
  };
  const result1 = sortTablesByKeyplayer(test1Tables, test1Roster);
  const expected1 = ['15', '23', '1', '2', '3'];
  console.log('Test 1 - 키플레이어 2개 테이블:', result1.join(',') === expected1.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected1);
  console.log('  Got:', result1);

  // Test 2: 키플레이어 없음
  const test2Tables = ['1', '2', '3'];
  const test2Roster = {
    '1': [{seat: 1, keyplayer: false}],
    '2': [{seat: 1, keyplayer: false}],
    '3': [{seat: 1, keyplayer: false}]
  };
  const result2 = sortTablesByKeyplayer(test2Tables, test2Roster);
  const expected2 = ['1', '2', '3'];
  console.log('Test 2 - 키플레이어 없음:', result2.join(',') === expected2.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected2);
  console.log('  Got:', result2);

  // Test 3: keyplayer 컬럼 없음 (하위 호환)
  const test3Tables = ['3', '1', '2'];
  const test3Roster = {
    '1': [{seat: 1, player: 'Alice', chips: 10000}],
    '2': [{seat: 1, player: 'Bob'}]
  };
  const result3 = sortTablesByKeyplayer(test3Tables, test3Roster);
  const expected3 = ['1', '2', '3'];
  console.log('Test 3 - keyplayer 컬럼 없음:', result3.join(',') === expected3.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected3);
  console.log('  Got:', result3);

  // Test 4: 빈 배열
  const result4 = sortTablesByKeyplayer([], test1Roster);
  console.log('Test 4 - 빈 배열:', result4.length === 0 ? '✅ PASS' : '❌ FAIL');

  // Test 5: roster 없음
  const result5 = sortTablesByKeyplayer(['3', '1', '2'], {});
  const expected5 = ['1', '2', '3'];
  console.log('Test 5 - roster 없음:', result5.join(',') === expected5.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected5);
  console.log('  Got:', result5);

  console.log('=== Test Complete ===');
}

/* ===== v3.3.2: EXTREME MINIMAL 기능 ===== */

// 스택 섹션 접기/펼치기
function toggleStackSection(){
  const grid = document.getElementById('stackGrid');
  const toggle = document.getElementById('stackToggle');
  if(grid.style.display === 'none'){
    grid.style.display = 'grid';
    toggle.textContent = '▲';
  }else{
    grid.style.display = 'none';
    toggle.textContent = '▼';
  }
  vibrate(HAPTIC.LIGHT);
}

// 스택 요약 업데이트
function updateStackSummary(){
  const entered = Object.keys(S.stacks).filter(seat => S.stacks[seat] > 0).length;
  const total = S.seats.filter(s => S.activeSeatMap[s.seat]).length;
  document.getElementById('stackSummary').textContent = `${entered}/${total}명`;
}

// 보드 오버레이 열기
function openBoardOverlay(){
  // v3.3.2: 보드 핸들러로 재빌드 (홀카드와 분리)
  console.log('[FIX] 보드 UI - toggleBoardCard 핸들러 연결');
  buildBoardUI('boardRowOverlay', toggleBoardCard);

  document.getElementById('ovTitle').textContent = '보드 카드 선택';
  document.getElementById('ovCount').textContent = ` · ${S.board.length}/5장`;

  const ov = document.getElementById('overlay');
  ov.style.display = 'flex';
  setTimeout(() => ov.classList.add('show'), 10);
  vibrate(HAPTIC.MEDIUM);

  syncBoardSelection('boardRowOverlay');
}

// 보드 디스플레이 업데이트
function updateBoardDisplay(){
  const display = document.getElementById('boardDisplay');
  if(!S.board || S.board.length === 0){
    display.innerHTML = '<span class="muted small">선택된 카드 없음</span>';
    return;
  }

  const badges = S.board.map(card => {
    const cc = cardCode(card);
    if(!cc) return '';
    const suit = cc.slice(-1), r = cc.slice(0, -1);
    const sym = suit === 's' ? '♠' : suit === 'h' ? '♥' : suit === 'd' ? '♦' : '♣';
    const cl = suit === 's' ? 'cb-s' : suit === 'h' ? 'cb-h' : suit === 'd' ? 'cb-d' : 'cb-c';
    return `<span class="cardBadge ${cl}" style="font-size:0.8rem">${r}${sym}</span>`;
  }).join('');

  display.innerHTML = `<div style="display:flex;gap:4px;flex-wrap:wrap">${badges}</div>`;
}

// Pills 렌더링 수정 (번호만)
const originalRenderSeatToggles = window.renderSeatToggles || function(){};
</script>
</body>
</html>
