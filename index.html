<!-- index — Poker Hand Logger — v3.3.0 (2025-01-15) -->
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Poker Hand Logger</title>
<!-- CSS embedded in style tag below -->
<style>
/* v2.6.0: 100vh No-Scroll 레이아웃 */
:root{font-size:28px;--bg:#0b0d12;--panel:#101522;--line:#1f2435;--muted:#9aa3b2;--acc:#2a6fff;--text:#e7eaf0}
*{box-sizing:border-box}
html,body{margin:0;padding:0;height:100vh;overflow:hidden;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
body{display:grid;grid-template-rows:8vh 1fr 12vh;grid-template-areas:"header" "main" "footer"}
header{grid-area:header;display:flex;justify-content:space-between;align-items:center;padding:0 14px;background:#0f1320;border-bottom:1px solid #222}
footer{grid-area:footer;display:flex;align-items:center;padding:0 14px;background:#0f1320;border-top:1px solid #222}
.wrap{grid-area:main;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
h3{margin:0 0 10px;color:#a9b8ff;font-size:1rem}
label{font-size:.8rem;color:var(--muted)}
select,input,button{background:#0f1320;color:var(--text);border:1px solid #2a3249;border-radius:12px;padding:12px;font-size:1rem}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:10px}.g2{grid-template-columns:1fr 1fr}
.pill{display:inline-flex;padding:8px 10px;border:1px solid #2a3249;border-radius:999px;cursor:pointer}
.pill.active{background:#223266;border-color:var(--acc)}
.seatCard{padding:10px;border:1px dashed #2a3249;border-radius:12px}
.small{font-size:.8rem}.muted{color:var(--muted)}
.hidden{display:none !important}
/* v2.5.0: 4×13 그리드 (Bottom Sheet용) */
.boardWrap{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;max-height:65vh;overflow:auto;padding:4px}
.suitCol{display:grid;grid-template-rows:repeat(13,1fr);gap:8px}
.card{min-height:56px;border-radius:10px;border:2px solid #2a3249;display:flex;justify-content:center;align-items:center;background:#0f1320;cursor:pointer;font-size:1.1rem;font-weight:700;touch-action:manipulation;user-select:none;transition:all 0.15s}
.card:active{transform:scale(0.95);background:#1a2035}
.card.sel{outline:3px solid var(--acc);background:#223266}
.actionDock{position:sticky;bottom:0;left:0;right:0;background:#0c1120;border-top:1px solid #20263a;padding:12px;z-index:5}
.actionDock .pad{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.actionDock button{height:66px;font-weight:700}
.btnPrimary{background:var(--acc);border-color:var(--acc)}
.holeBadge{display:inline-flex;gap:6px}
.badge{padding:6px 8px;border:1px solid #2a3249;border-radius:999px}
.badge.click{cursor:pointer}

/* v2.5.0: Bottom Sheet (기존 overlay 대체) */
#overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:flex-end;justify-content:center;z-index:20;opacity:0;transition:opacity 0.3s}
#overlay.show{opacity:1}
#overlay .box{width:100%;max-width:680px;max-height:85vh;background:#0f1320;border:1px solid #2a3249;border-radius:20px 20px 0 0;padding:16px;transform:translateY(100%);transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);will-change:transform}
#overlay.show .box{transform:translateY(0)}
.logbox{max-height:22vh;overflow:auto;border:1px solid #1b2133;border-radius:10px;padding:8px;background:#0e1320}

/* === Review 배지 & 보드 (v3.1.0: 밀도 최적화) === */
.badgeRow{display:flex;flex-wrap:wrap;gap:4px}
.cardBadge{display:inline-flex;align-items:center;justify-content:center;min-width:32px;height:32px;padding:0 4px;border-radius:6px;border:2px solid;background:#ffffff;font-weight:700;font-size:0.85rem}
.cb-s{border-color:#111111;color:#111111}
.cb-h{border-color:#ef4444;color:#ef4444}
.cb-d{border-color:#ef4444;color:#ef4444}
.cb-c{border-color:#111111;color:#111111}
.actBadge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px;border:1px solid;font-weight:600;font-size:0.75rem;white-space:nowrap}
.act-chk{border-color:#22c55e;background:rgba(34,197,94,.1);color:#86efac}
.act-call{border-color:#22c55e;background:rgba(34,197,94,.1);color:#86efac}
.act-bet{border-color:#ef4444;background:rgba(239,68,68,.1);color:#fca5a5}
.act-raise{border-color:#ef4444;background:rgba(239,68,68,.1);color:#fca5a5}
.act-fold{border-color:#3b82f6;background:rgba(59,130,246,.1);color:#93c5fd}
.act-allin{border-color:#b91c1c;background:rgba(185,28,28,.15);color:#fca5a5}
.streetTitle{margin:8px 0 2px;font-weight:700;font-size:0.8rem;color:#94a3b8;cursor:pointer;user-select:none}
.streetTitle:hover{color:#a9b8ff}
.playerName{font-weight:700}

/* 설정 토글 */
.settings{display:flex;gap:8px;align-items:center}
.settings input{min-width:220px}

/* v2.4.0: 키플레이어 하이라이트 */
.pill.keyplayer{background:linear-gradient(135deg,#fbbf24,#f59e0b);border-color:#f59e0b;color:#000;font-weight:800}
.pill.keyplayer.active{background:linear-gradient(135deg,#fcd34d,#fbbf24);box-shadow:0 0 12px rgba(251,191,36,0.6)}

/* v2.6.0: Context Bar (1줄 압축) */
.contextBar{display:flex;gap:8px;align-items:center;padding:8px 12px;background:#0e1322;border-radius:10px;font-size:0.75rem;overflow-x:auto;white-space:nowrap}
.contextBar .item{padding:4px 10px;border-radius:8px;background:#1a2035;border:1px solid #2a3249}
.contextBar .item.active{background:#223266;border-color:var(--acc)}

/* v2.6.0: Seats Pills (원형, 가로 스크롤) */
.seatsWrap{display:flex;gap:8px;overflow-x:auto;padding:8px 0}
.seatPill{min-width:64px;height:64px;display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:999px;border:2px solid #2a3249;background:#0f1320;cursor:pointer;font-size:0.7rem;text-align:center;flex-shrink:0}
.seatPill.active{background:#223266;border-color:var(--acc)}
.seatPill.keyplayer{background:linear-gradient(135deg,#fbbf24,#f59e0b);border-color:#f59e0b;color:#000;font-weight:800}

/* v2.9.0: Keyplayer 테이블 드롭다운 강조 */
select#tableSel option.keyplayer-option {
  font-weight: 800;
  background: linear-gradient(135deg, #fef3c7, #fde68a);
  color: #92400e;
}

/* 선택된 keyplayer 테이블 (closed dropdown) */
select#tableSel:has(option.keyplayer-option:checked) {
  font-weight: 700;
  color: #92400e;
}

/* === Review 2-Panel 레이아웃 (v3.0.0: 9:16 최적화) === */
#panelReview{display:flex;flex-direction:column;gap:12px;height:100%}
#reviewContainer{display:flex;gap:12px;width:100%;height:calc(100vh - 200px);overflow:hidden}
#list{flex:0 0 35%;height:100%;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:8px;background:#0e1320}
#detail{flex:1;height:100%;overflow-y:auto;border:1px solid var(--line);border-radius:10px;padding:12px;background:#0e1320;scrollbar-width:thin;scrollbar-color:#2a3249 #0e1320}
#detail::-webkit-scrollbar{width:8px}
#detail::-webkit-scrollbar-track{background:#0e1320}
#detail::-webkit-scrollbar-thumb{background:#2a3249;border-radius:4px}
.seatCard.selected{border:2px solid var(--acc);background:rgba(42,111,255,.1)}

/* === Review 상세 디자인 (v3.2.0: 극한 밀도) === */
.potHeader{display:flex;justify-content:space-between;align-items:center;padding:2px 0;border-bottom:1px solid var(--line);margin-bottom:2px;font-size:0.8rem}
.boardSection{margin:4px 0}
.playerSection{margin:4px 0}
.playerRow{display:flex;gap:4px;padding:1px 0;align-items:center;font-size:0.7rem;flex-wrap:wrap}
.playerName{font-weight:700;min-width:50px}
.playerHole{display:flex;gap:2px}
.playerStack{color:var(--muted);margin-left:auto}
.sectionDivider{height:1px;background:var(--line);margin:4px 0}
.potFooter{display:none}
.cardBadgeSmall{display:inline-flex;align-items:center;justify-content:center;min-width:28px;height:28px;padding:0 4px;border-radius:4px;border:2px solid;background:#ffffff;font-size:0.7rem;font-weight:700}
.boardSmall{display:flex;gap:3px;margin-top:3px;flex-wrap:wrap}
.detailMeta{font-size:0.7rem;color:var(--muted);margin:2px 0}
.streetRow{margin:2px 0;font-size:0.75rem;line-height:1.8}
.streetTitle{display:inline;cursor:pointer;font-weight:700;color:#94a3b8;margin-right:6px}
.streetTitle:hover{color:#a9b8ff}
.streetBadges{display:inline}
</style>
</head>
<body>
<header class="row" style="justify-content:space-between">
  <div><strong>Poker Hand Logger</strong><span class="muted small"> · 모바일 최적화 · 기여액 기반 · v3.3.0</span></div>
  <div class="row">
    <button id="modeRecord" type="button" class="btnPrimary">Record</button>
    <button id="modeReview" type="button">Review</button>
  </div>
</header>

<div class="wrap">
  <div class="panel" id="panelRecord">
    <h3>Record</h3>

    <!-- BB 설정 (v2.3.0: External Sheet ID 제거) -->
    <div class="panel" style="background:#0e1322; margin-bottom:10px">
      <div class="row settings small">
        <label>Big Blind(원)</label>
        <input id="bbInput" type="text" inputmode="numeric" placeholder="예: 1,000"/>
        <button id="saveSettingsBtn" type="button">설정 저장</button>
      </div>
      <div class="small muted" id="settingsMsg"></div>
    </div>

    <div class="grid g2">
      <div><label>테이블</label><select id="tableSel"></select></div>
      <div><label>핸드 No.</label><input id="handNo" type="number" placeholder="자동부여(선택)"/></div>
      <div>
        <label>시작 스트릿(고정)</label>
        <select id="streetStart">
          <option value="PREFLOP">Preflop</option>
          <option value="FLOP">Flop</option>
          <option value="TURN">Turn</option>
          <option value="RIVER">River</option>
        </select>
      </div>
      <div><label>BTN 좌석</label><select id="btnSeat"></select></div>
      <div style="grid-column:1/-1"><label>선 누적 팟(pre_pot, 선택)</label><input type="text" inputmode="numeric" id="prePot" placeholder="예: 12,500" style="width:100%"/></div>
    </div>

    <div style="margin-top:10px">
      <label>참여 좌석 선택(비참여 제외)</label>
      <div id="seatsRow" class="row"></div>
    </div>

    <div id="stackGrid" class="grid" style="grid-template-columns:1fr; margin-top:10px"></div>

    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div class="row small">
        <b>보드(카드 토글)</b><span class="muted"> · A→2 / ♠→♥→♦→♣ · 재탭 해제 · 5장까지</span>
        <span class="muted">· 현재 스트릿: <b id="curStreetTag">-</b></span>
      </div>
      <div id="boardRowRecord" class="boardWrap" style="margin-top:6px"></div>
    </div>

    <div class="panel" style="margin-top:10px;background:#0e1322">
      <div class="row small">
        <div>현재 차례: <b id="turnSeat">-</b></div>
        <div>· toCall: <b id="toCall">0</b> · pot: <b id="pot">0</b></div>
      </div>
      <div id="actionFeed" class="logbox small"></div>
    </div>

    <div class="actionDock">
      <div class="pad" id="actionPad"></div>

      <div class="row" style="margin-top:8px; gap:10px;">
        <button id="undoBtn" type="button" style="flex:1;">Undo</button>
        <button id="newHandBtn" type="button" style="flex:1;">새 핸드</button>
      </div>

      <div class="row" style="margin-top:8px; gap:0;">
        <button id="commitBtn" type="button" class="btnPrimary"
                style="flex:1; border-radius:12px 0 0 12px; border-right:1px solid #1a2540;">
          데이터 전송(커밋)
        </button>
        <button id="sendVirtualRecordBtn" type="button" class="btnPrimary"
                onclick="sendRecordToVirtual()"
                style="flex:1; border-radius:0 12px 12px 0; background:#f59e0b; border-color:#f59e0b;">
          📤 VIRTUAL 전송
        </button>
      </div>

      <div id="virtualRecordOptions"
           style="margin-top:6px; font-size:0.7rem; display:flex; gap:4px; flex-wrap:wrap; align-items:center; padding:4px; background:#0e1322; border-radius:4px;">
      </div>

      <div style="margin-top:4px; display:flex; gap:8px; align-items:center;">
        <span id="commitMsg" class="small muted" style="flex:1;"></span>
        <span id="virtualRecordMsg" class="small muted"></span>
      </div>
    </div>
  </div>

  <div class="panel hidden" id="panelReview">
    <h3>Review</h3>
    <!-- v3.0.0: VIRTUAL 시트 설정 UI (간소화 - 전송 기능은 핸드 상세에서) -->
    <div class="panel" style="background:#0e1322; margin-bottom:10px">
      <div class="row settings small">
        <label>VIRTUAL Sheet ID</label>
        <input id="virtualSheetId" type="text" placeholder="예: 13LpVWYH... (VIRTUAL 시트 소속 스프레드시트 ID)"/>
        <button id="saveVirtualBtn" type="button">저장</button>
      </div>
      <div class="small muted" id="virtualMsg"></div>
    </div>
    <div class="row">
      <button id="refreshList" type="button">새로고침</button>
      <span id="listInfo" class="small muted"></span>
    </div>
    <div id="reviewContainer">
      <div id="list"></div>
      <div id="detail" class="small"></div>
    </div>
  </div>
</div>

<footer class="row"><span class="small muted">BTN만 · 사이드팟 자동계산 없음 · 보드 미완성 허용 · ALL-IN 금액 수동 · v3.3.0</span></footer>

<!-- v2.5.0: Bottom Sheet 홀카드 선택 -->
<div id="overlay"><div class="box">
  <div style="width:40px;height:4px;background:#4a5568;border-radius:2px;margin:0 auto 12px"></div>
  <div class="row small" style="margin-bottom:12px"><b id="ovTitle">홀카드 선택</b><span class="muted"> · 2장까지</span><span class="muted" id="ovCount"></span></div>
  <div id="boardRowOverlay" class="boardWrap"></div>
  <div class="row" style="margin-top:12px;justify-content:center"><button type="button" onclick="closeOverlay()" style="min-width:120px;height:48px">닫기</button></div>
</div></div>

<script>
/* ===== Poker Hand Logger — v3.3.0 (2025-01-15) ===== */
const S={tables:[],roster:{},cfg:{},
  curTable:null,startStreetInit:'PREFLOP',curStreet:'PREFLOP',
  btnSeat:null,seats:[],activeSeatMap:{},prePot:0,actions:[],nextSeq:1,board:[],
  toCall:0,pot:0,contrib:{},allin:{},folded:{},actorIdx:0,order:[],acted:new Set(),
  holes:{},holePickSeat:null,handNo:'',stacks:{},
  virtualSheetId:'',bbValue:0,
  nextHandNo:1}; // v3.3.0: 다음 핸드 번호 (자동 증가)

const SUITS=['s','h','d','c'];
const RANKS=['A','K','Q','J','T','9','8','7','6','5','4','3','2'];

/* v2.5.0: 햅틱 피드백 상수 */
const HAPTIC={LIGHT:20,MEDIUM:30,STRONG:50};
function vibrate(ms){if(navigator.vibrate) navigator.vibrate(ms);}

/* v2.6.0: SessionStorage 캐싱 (1분 TTL) */
function cacheGet(key){
  const cached=sessionStorage.getItem(key);
  if(!cached) return null;
  try{
    const obj=JSON.parse(cached);
    if(Date.now()-obj.timestamp<60000) return obj.data;
    sessionStorage.removeItem(key);
  }catch(e){}
  return null;
}
function cacheSet(key,data){ sessionStorage.setItem(key,JSON.stringify({timestamp:Date.now(),data})); }

/* v2.6.0: PERF 측정 */
const PERF={};
function perfStart(label){PERF[label]=performance.now();}
function perfEnd(label){if(PERF[label])console.log(`[PERF] ${label}: ${(performance.now()-PERF[label]).toFixed(1)}ms`);}

/* ===== v2.9.0: Keyplayer 테이블 우선 정렬 ===== */
/**
 * keyplayer가 있는 테이블을 최상단으로 정렬 (Record 모드용)
 * - keyplayer ≥ 1명: 최상단 그룹 (번호순 정렬)
 * - keyplayer 0명: 하단 그룹 (번호순 정렬)
 * - 하위 호환: keyplayer 컬럼 없으면 모든 테이블 일반 처리
 *
 * @param {string[]} tables - 테이블 ID 배열 (예: ['1', '15', '2', '23'])
 * @param {Object} roster - S.roster 객체 {tableId: [{seat, player, keyplayer}, ...]}
 * @returns {string[]} 정렬된 테이블 배열 (keyplayer 테이블 우선)
 */
function sortTablesByKeyplayer(tables, roster) {
  // 입력 검증
  if (!tables || !Array.isArray(tables) || tables.length === 0) {
    return [];
  }

  // roster 없으면 원본 번호순 정렬 (하위 호환)
  if (!roster || Object.keys(roster).length === 0) {
    console.warn('[v2.9.0] sortTablesByKeyplayer: roster 데이터 없음 - 번호순 정렬로 fallback');
    return tables.slice().sort(sortByNumber_);
  }

  const withKeyplayer = [];
  const withoutKeyplayer = [];

  // 각 테이블의 keyplayer 여부 체크
  tables.forEach(tableId => {
    const players = roster[tableId] || [];

    // keyplayer 필드 안전 접근 (undefined → false)
    const hasKeyplayer = players.some(p => p.keyplayer === true);

    if (hasKeyplayer) {
      withKeyplayer.push(tableId);
    } else {
      withoutKeyplayer.push(tableId);
    }
  });

  // 각 그룹 내부를 번호순 정렬
  withKeyplayer.sort(sortByNumber_);
  withoutKeyplayer.sort(sortByNumber_);

  // keyplayer 테이블 최상단 배치
  return [...withKeyplayer, ...withoutKeyplayer];
}

/**
 * 테이블 번호 기준 정렬 (숫자 변환 지원)
 * @param {string} a - 테이블 ID
 * @param {string} b - 테이블 ID
 * @returns {number} 정렬 순서
 */
function sortByNumber_(a, b) {
  const numA = parseInt(a, 10);
  const numB = parseInt(b, 10);

  // 숫자 변환 실패 시 문자열 비교
  if (isNaN(numA) || isNaN(numB)) {
    return String(a).localeCompare(String(b));
  }

  return numA - numB;
}

/* ===== 초기 로딩 ===== */
perfStart('init');
const cachedConfig=cacheGet('phl_config');
if(cachedConfig){ initFromConfig(cachedConfig); }
else{ google.script.run.withSuccessHandler(d=>{cacheSet('phl_config',d); initFromConfig(d);}).getConfig(); }

function initFromConfig(data){
  perfEnd('init');
  S.roster=data.roster; S.cfg=data.config||{};

  // v2.9.0: keyplayer 테이블 우선 정렬 (Record 모드용)
  S.tables = sortTablesByKeyplayer(data.tables, S.roster);
  // 설정 복원 (v2.3.0: virtualSheetId는 Review용)
  S.virtualSheetId = localStorage.getItem('phl_virtualSheetId')||'';
  S.bbValue = toInt(localStorage.getItem('phl_bbSize')||'0');

  // v3.3.0: BB 입력 포맷팅
  const bbInput = document.getElementById('bbInput');
  bbInput.value = S.bbValue ? formatNumber(S.bbValue) : '';
  bbInput.addEventListener('input', e => {
    const cursorPos = e.target.selectionStart;
    const oldLen = e.target.value.length;
    const cleaned = parseFormattedNumber(e.target.value);
    const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
    e.target.value = formatted;
    // 커서 위치 보정 (콤마 추가로 인한 이동)
    const newLen = formatted.length;
    const diff = newLen - oldLen;
    e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
  });

  document.getElementById('saveSettingsBtn').onclick=saveSettings_;
  document.getElementById('settingsMsg').textContent= S.bbValue ? `BB=${formatNumber(S.bbValue)}` : 'BB를 설정하세요';

  // Review 모드 VIRTUAL 설정 (v3.0.0: 전송 버튼 제거, 설정만 유지)
  document.getElementById('virtualSheetId').value=S.virtualSheetId;
  document.getElementById('saveVirtualBtn').onclick=saveVirtualSettings_;
  document.getElementById('virtualMsg').textContent= S.virtualSheetId ? `VIRTUAL 시트 저장됨` : 'VIRTUAL 시트ID를 설정하세요';

  const sel=document.getElementById('tableSel');
  // v2.9.0: keyplayer 테이블 강조 표시
  sel.innerHTML = `<option value="">테이블 선택</option>${S.tables.map(t => {
    const players = S.roster[t] || [];
    const keyplayerCount = players.filter(p => p.keyplayer === true).length;
    const isKeyplayer = keyplayerCount > 0;

    // ⭐ 아이콘 + keyplayer 수 표시
    const label = isKeyplayer
      ? `⭐ Table ${t} (${keyplayerCount} Key Player${keyplayerCount > 1 ? 's' : ''})`
      : `Table ${t}`;
    const className = isKeyplayer ? 'keyplayer-option' : '';

    return `<option value="${t}" class="${className}">${label}</option>`;
  }).join('')}`;
  sel.onchange=onTableChange;

  const streetSel=document.getElementById('streetStart');
  streetSel.onchange=e=>{ S.startStreetInit=e.target.value; S.curStreet=S.startStreetInit; resetHandState(false); renderAll(); };

  document.getElementById('btnSeat').onchange=e=>{S.btnSeat=toInt(e.target.value); buildTurnOrder(); renderAll();};

  // v3.3.0: prePot 포맷팅
  const prePotInput = document.getElementById('prePot');
  prePotInput.addEventListener('input', e => {
    const cursorPos = e.target.selectionStart;
    const oldLen = e.target.value.length;
    const cleaned = parseFormattedNumber(e.target.value);
    const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
    e.target.value = formatted;
    S.prePot = cleaned;
    S.pot = S.prePot + sumObj(S.contrib);
    renderPot();
    // 커서 위치 보정
    const newLen = formatted.length;
    const diff = newLen - oldLen;
    e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
  });
  // v3.3.0: handNo 입력 필드 - 자동 채움 + 수동 수정 가능
  const handNoInput = document.getElementById('handNo');
  handNoInput.oninput = e => {
    const val = e.target.value;
    if (val && val.trim() !== '') {
      S.nextHandNo = toInt(val); // 수동 수정 시 nextHandNo 동기화
    }
  };

  document.getElementById('undoBtn').onclick=undoOnce;
  document.getElementById('commitBtn').onclick=commitHand;
  document.getElementById('newHandBtn').onclick=()=>resetHandState(true);
  document.getElementById('refreshList').onclick=()=>loadList(true);
  document.getElementById('modeRecord').onclick=()=>setMode('record');
  document.getElementById('modeReview').onclick=()=>setMode('review');

  // v1.2.0: 무한 스크롤
  document.getElementById('list').addEventListener('scroll', e=>{
    const el=e.target; if(el.scrollHeight-el.scrollTop-el.clientHeight<100) loadList(false);
  });

  setMode('record');
  buildBoardUI('boardRowRecord', toggleBoardCard);
  buildBoardUI('boardRowOverlay', pickCardOverlay);
  document.getElementById('streetStart').value=S.startStreetInit;
  renderAll();
  loadList();

  // v3.3.0: 앱 시작 시 다음 핸드 번호 조회
  initNextHandNo();
}

/* ===== v3.3.0: Auto Hand Number ===== */
function initNextHandNo() {
  google.script.run
    .withSuccessHandler(num => {
      S.nextHandNo = num;
      updateHandNoDisplay();
    })
    .withFailureHandler(err => {
      console.error('getNextHandNo failed:', err);
      S.nextHandNo = 1; // fallback
      updateHandNoDisplay();
    })
    .getNextHandNo();
}

function updateHandNoDisplay() {
  const input = document.getElementById('handNo');
  if (input) {
    input.value = S.nextHandNo;
    input.placeholder = `자동: ${S.nextHandNo}`;
  }
}

function saveSettings_(){
  // v3.3.0: 포맷팅된 입력값 파싱
  S.bbValue = parseFormattedNumber(document.getElementById('bbInput').value||'0');
  localStorage.setItem('phl_bbSize', S.bbValue);
  document.getElementById('settingsMsg').textContent=`저장됨 (BB=${formatNumber(S.bbValue)})`;
  setTimeout(()=>document.getElementById('settingsMsg').textContent='',1500);
}

function saveVirtualSettings_(){
  S.virtualSheetId = (document.getElementById('virtualSheetId').value||'').trim();
  localStorage.setItem('phl_virtualSheetId', S.virtualSheetId);
  document.getElementById('virtualMsg').textContent='저장됨';
  setTimeout(()=>document.getElementById('virtualMsg').textContent='',1500);
}

function setMode(m){
  const rec=document.getElementById('panelRecord'), rev=document.getElementById('panelReview');
  const bR=document.getElementById('modeRecord'), bV=document.getElementById('modeReview');
  if(m==='record'){
    rec.classList.remove('hidden'); rev.classList.add('hidden'); bR.classList.add('btnPrimary'); bV.classList.remove('btnPrimary');
    renderVirtualRecordOptions();
  }
  else{rev.classList.remove('hidden'); rec.classList.add('hidden'); bV.classList.add('btnPrimary'); bR.classList.remove('btnPrimary'); loadList(true);}
}

/* ===== 테이블 변경 ===== */
function onTableChange(e){
  S.curTable=e.target.value||null;
  const arr=(S.roster[S.curTable]||[]).slice().sort((a,b)=>a.seat-b.seat);
  S.seats=arr.map(x=>({seat:toInt(x.seat), name:x.player, nation:x.nation, chips:x.chips, keyplayer:x.keyplayer}));
  S.activeSeatMap={}; S.seats.forEach(s=>S.activeSeatMap[s.seat]=true);
  S.folded={}; S.allin={}; S.stacks={};
  const btnDefault=toInt(S.cfg[S.curTable]?.btn_seat)||'';
  const btnSel=document.getElementById('btnSeat');
  // v2.4.0: BTN 드롭다운에 keyplayer ⭐ 표시
  btnSel.innerHTML=`<option value="">BTN 선택</option>${S.seats.map(s=>{
    const rosterEntry=(S.roster[S.curTable]||[]).find(r=>toInt(r.seat)===s.seat);
    const isKey=rosterEntry && rosterEntry.keyplayer;
    return `<option value="${s.seat}" ${s.seat==btnDefault?'selected':''}>${isKey?'⭐ ':''}${seatShort(s.seat,s.name)}</option>`;
  }).join('')}`;
  S.btnSeat=btnDefault||null; S.handNo=''; document.getElementById('handNo').value='';
  S.curStreet=S.startStreetInit; resetHandState(false); renderAll();
  renderVirtualRecordOptions();
}

/* ===== 핸드 상태 ===== */
function resetHandState(clearInputs){
  S.contrib={}; S.actions=[]; S.nextSeq=1; S.board=[]; S.holes={};
  S.pot=S.prePot; S.toCall=0; S.allin={}; S.folded={}; S.acted=new Set();
  S.curStreet=S.startStreetInit; buildTurnOrder(); renderAll();
  if(clearInputs){
    document.getElementById('commitMsg').textContent='새 핸드 시작';
    renderVirtualRecordOptions();
    // v3.3.0: 새 핸드 시작 시 hand_no 표시 업데이트
    updateHandNoDisplay();
  }
}

function buildTurnOrder(){
  const active=S.seats.map(s=>toInt(s.seat)).filter(seat=>S.activeSeatMap[seat]).sort((a,b)=>a-b);
  S.order=[]; if(!active.length){S.actorIdx=0; return;}
  const btn=toInt(S.btnSeat);
  if(S.curStreet!=='PREFLOP'){
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    const rotated=active.slice(start).concat(active.slice(0,start));
    const filtered=rotated.filter(v=>v!==btn); if(active.includes(btn)) filtered.push(btn);
    S.order=filtered;
  }else{
    let start=active.findIndex(v=>v>btn); if(start===-1) start=0;
    S.order=active.slice(start).concat(active.slice(0,start));
  }
  S.actorIdx=0; skipInvalidActors();
}

function skipInvalidActors(){
  if(S.order.length===0) return;
  let guard=0;
  while(guard<50){
    const seat=S.order[S.actorIdx%S.order.length];
    if(!S.activeSeatMap[seat] || S.allin[seat] || S.folded[seat]){ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; continue; }
    break;
  }
}

/* ===== 렌더 ===== */
function renderAll(){
  // v2.6.0: requestAnimationFrame으로 렌더링 최적화
  requestAnimationFrame(()=>{
    renderSeatToggles(); renderStackGrid(); renderActionPad(); renderTurnSeat(); renderPot(); renderFeed();
    syncBoardSelection('boardRowRecord'); document.getElementById('curStreetTag').textContent=S.curStreet;
  });
}

function seatShort(seat,name){
  const n=String(name||'').trim(); if(!n) return `#${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `#${seat} ${init}${last}`;
}
function seatNameOnly(seat,name){
  const n=String(name||'').trim(); if(!n) return `Seat ${seat}`;
  const parts=n.split(/\s+/); let first=parts[0]||'', last=parts.slice(1).join(' ');
  if(!last){last=first; first='';} const init=first?first[0].toUpperCase()+'.':'';
  return `${init}${last}`;
}

function renderSeatToggles(){
  const box=document.getElementById('seatsRow');
  if(!S.seats.length){box.innerHTML='<span class="muted small">테이블을 먼저 선택</span>'; return;}
  box.innerHTML='';
  S.seats.forEach(s=>{
    const el=document.createElement('div');
    // v2.4.0: keyplayer 체크
    const rosterEntry=(S.roster[S.curTable]||[]).find(r=>toInt(r.seat)===s.seat);
    const isKey=rosterEntry && rosterEntry.keyplayer;
    const isActive=S.activeSeatMap[s.seat];
    // v3.2.1: keyplayer 하이라이트는 active일 때만 표시
    el.className='pill '+(isKey && isActive?'keyplayer ':'')+(isActive?'active':'');
    el.textContent=(isKey?'⭐ ':'')+seatShort(s.seat,s.name);
    el.title=isKey?'키플레이어 (J열 자막 생성)':'';
    el.onclick=()=>{ if(S.actions.length>0) return; S.activeSeatMap[s.seat]=!S.activeSeatMap[s.seat]; buildTurnOrder(); renderAll(); };
    box.appendChild(el);
  });
}

function renderStackGrid(){
  const grid=document.getElementById('stackGrid'); grid.innerHTML='';
  S.seats.filter(s=>S.activeSeatMap[s.seat]).forEach(s=>{
    const [c1,c2]=(S.holes[s.seat]||['','']);
    const wrap=document.createElement('div'); wrap.className='seatCard';
    // v3.3.0: stack 값 포맷팅
    const stackVal = S.stacks[s.seat];
    const displayVal = stackVal ? formatNumber(stackVal) : '';
    wrap.innerHTML = `
      <div class="small"><span class="playerName">${seatNameOnly(s.seat,s.name)}</span></div>
      <div class="row">
        <input type="text" inputmode="numeric" class="stack-input" data-seat="${s.seat}" placeholder="stack(선택)" value="${displayVal}" />
      </div>
      <div class="row small" style="margin-top:6px">
        <span class="muted">홀카드:</span>
        <span class="holeBadge">
          <span class="badge click" onclick="openHoleOverlay(${s.seat})">${prettyCard(c1)||'Card1'}/${prettyCard(c2)||'Card2'}</span>
          <button type="button" onclick="clearHole(${s.seat})">지우기</button>
        </span>
      </div>`;
    grid.appendChild(wrap);

    // v3.3.0: stack 입력 포맷팅 이벤트
    const input = wrap.querySelector('.stack-input');
    input.addEventListener('input', e => {
      const seat = toInt(e.target.dataset.seat);
      const cursorPos = e.target.selectionStart;
      const oldLen = e.target.value.length;
      const cleaned = parseFormattedNumber(e.target.value);
      const formatted = cleaned > 0 ? formatNumber(cleaned) : '';
      e.target.value = formatted;
      S.stacks[seat] = cleaned;
      // 커서 위치 보정
      const newLen = formatted.length;
      const diff = newLen - oldLen;
      e.target.setSelectionRange(cursorPos + diff, cursorPos + diff);
    });
  });
}
window.S_setStack=(seat,v)=>{ S.stacks[seat]=parseFormattedNumber(v); };

function renderActionPad(){
  const pad=document.getElementById('actionPad'); pad.innerHTML='';
  const seat=currentActorSeat(); if(!seat){pad.innerHTML='<button type="button" disabled>대기</button>'; return;}
  const hasToCall=S.toCall>0;
  (hasToCall?['CALL','RAISE','FOLD','ALLIN']:['CHECK','BET','FOLD','ALLIN']).forEach(kind=>{
    const el=document.createElement('button'); el.type='button'; el.textContent=kind; el.onclick=()=>onAction(kind,seat); pad.appendChild(el);
  });
}
function renderTurnSeat(){ document.getElementById('turnSeat').textContent=currentActorSeat()?('Seat '+currentActorSeat()):'-'; }
function renderPot(){
  // v3.3.0: 숫자 포맷팅 적용
  document.getElementById('toCall').textContent=formatNumber(S.toCall);
  document.getElementById('pot').textContent=formatNumber(S.pot);
}
function currentActorSeat(){ if(S.order.length===0) return null; return S.order[S.actorIdx%S.order.length]; }

function renderFeed(){
  const box=document.getElementById('actionFeed');
  if(!S.actions.length){ box.innerHTML='<span class="muted">아직 액션 없음</span>'; return; }
  box.innerHTML=S.actions.map(a=>{
    const nm = seatNameOnly(a.seat, getSeatName(a.seat));
    return `#${a.seq} · ${a.street} · ${nm} · ${a.action}${a.amount_input?(' '+a.amount_input):''} → toCall ${a.to_call_after} · pot ${a.pot_after}`;
  }).join('<br/>');
  box.scrollTop=box.scrollHeight;
}

/* ===== 액션 ===== */
function onAction(kind,seat){
  if(kind==='FOLD'){ S.folded[seat]=true; applyAction({seat,action:'FOLD',amt:0}); return; }
  if(kind==='CHECK'){ if(S.toCall>0) return; applyAction({seat,action:'CHECK',amt:0}); return; }
  if(kind==='CALL'){ const need=Math.max(0, maxContribAll()- (S.contrib[seat]||0)); applyAction({seat,action:'CALL',amt:need}); return; }
  if(kind==='BET'||kind==='RAISE'||kind==='ALLIN'){
    let def='';
    if(kind==='ALLIN' && S.stacks[seat]!=null){
      const remain = Math.max(0, S.stacks[seat] - (S.contrib[seat]||0)); def = String(remain);
    }
    const val=prompt(`금액 입력 (${kind})`, def); if(val===null) return;
    applyAction({seat,action:(kind==='ALLIN')?'ALLIN':kind,amt:toInt(val)}); return;
  }
}

function applyAction({seat,action,amt}){
  const prev=S.contrib[seat]||0; S.contrib[seat]=prev+(toInt(amt)||0);
  if(action==='ALLIN') S.allin[seat]=true;
  S.pot=S.prePot+sumObj(S.contrib);
  if(action==='BET'||action==='RAISE'||action==='ALLIN'){ S.acted=new Set([seat]); }
  else if(action==='CHECK'||action==='CALL'){ S.acted.add(seat); }
  computeToCall();
  S.actions.push({seq:S.nextSeq++,street:S.curStreet,seat,action,amount_input:toInt(amt)||0,to_call_after:S.toCall,contrib_after_seat:S.contrib[seat],pot_after:S.pot});
  advanceActor(); renderAll();
  renderVirtualRecordOptions();
  if(isStreetComplete()){
    const nxt=nextStreet(S.curStreet);
    if(nxt){ S.curStreet=nxt; S.acted=new Set(); computeToCall(); buildTurnOrder(); renderAll(); }
  }
}

/* === toCall === */
function maxContribAll(){
  const seats=S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.folded[seat]);
  let m=0; for(const s of seats){ m=Math.max(m, S.contrib[s]||0); } return m;
}
function computeToCall(){
  const maxC=maxContribAll(); let maxNeed=0;
  for(const s of aliveNonAllin()){
    const need=Math.max(0, maxC-(S.contrib[s]||0)); if(need>maxNeed) maxNeed=need;
  }
  S.toCall=maxNeed;
}
function aliveNonAllin(){ return S.seats.map(x=>x.seat).filter(seat=>S.activeSeatMap[seat] && !S.allin[seat] && !S.folded[seat]); }
function advanceActor(){ if(S.order.length===0) return; let guard=0; do{ S.actorIdx=(S.actorIdx+1)%S.order.length; guard++; } while(guard<50 && (!S.activeSeatMap[currentActorSeat()] || S.allin[currentActorSeat()] || S.folded[currentActorSeat()])); }
function isStreetComplete(){ const alive=aliveNonAllin(); if(alive.length<=1) return true; const everyoneActed = S.acted && (S.acted.size>=alive.length); return (S.toCall===0 && everyoneActed); }
function nextStreet(st){ if(st==='PREFLOP') return 'FLOP'; if(st==='FLOP') return 'TURN'; if(st==='TURN') return 'RIVER'; return null; }
function undoOnce(){
  if(S.actions.length===0) return;
  const last=S.actions.pop(); S.nextSeq--;
  S.contrib[last.seat]=(S.contrib[last.seat]||0)-(toInt(last.amount_input)||0);
  if(S.contrib[last.seat]<0) S.contrib[last.seat]=0;
  if(last.action==='ALLIN') S.allin[last.seat]=false;
  if(last.action==='FOLD') S.folded[last.seat]=false;
  S.curStreet = S.actions.length ? S.actions[S.actions.length-1].street : S.startStreetInit;
  S.pot=S.prePot+sumObj(S.contrib); computeToCall();
  S.actorIdx=Math.max(0,S.actorIdx-1)%((S.order.length)||1);
  S.acted=new Set(S.actions.filter(a=>a.street===S.curStreet).map(a=>a.seat));
  buildTurnOrder(); renderAll();
}

/* ===== 카드 UI ===== */
function buildBoardUI(containerId, handler){
  const box=document.getElementById(containerId); box.innerHTML='';
  SUITS.forEach(s=>{
    const col=document.createElement('div'); col.className='suitCol';
    RANKS.forEach(r=>{
      const c=r+s; const el=document.createElement('div'); el.className='card';
      el.textContent=prettyCard(c);
      // v2.5.0: touchstart 즉시 반응 + 햅틱
      el.addEventListener('touchstart', (e)=>{e.preventDefault(); vibrate(HAPTIC.LIGHT); handler(c,el);}, {passive:false});
      el.onclick=()=>handler(c,el);
      col.appendChild(el);
    });
    box.appendChild(col);
  });
}
function prettyCard(cs){
  if(!cs) return ''; const cc=cardCode(cs); const suit=cc.slice(-1), r=cc.slice(0,-1);
  const map={s:'♠',h:'♥',d:'♦',c:'♣'}; return r+map[suit];
}
function toggleBoardCard(card,el){
  const i=S.board.indexOf(card);
  if(i>=0){S.board.splice(i,1); el.classList.remove('sel'); vibrate(HAPTIC.LIGHT); return;}
  if(S.board.length>=5) return;
  S.board.push(card); el.classList.add('sel'); vibrate(HAPTIC.MEDIUM);
}
function syncBoardSelection(id){
  const box=document.getElementById(id); if(!box) return;
  [...box.querySelectorAll('.card')].forEach(dom=>{
    const c=labelToCode(dom.textContent);
    if(S.board.includes(c)) dom.classList.add('sel'); else dom.classList.remove('sel');
  });
}
function labelToCode(label){
  const r=label.replace(/[♠♥♦♣]/,'').trim();
  const sMap={'♠':'s','♥':'h','♦':'d','♣':'c'}; const sym=label.slice(-1);
  return r + (sMap[sym]||'');
}

/* 홀카드 오버레이(2장 연속 선택) — 보드중복 차단(단방향) */
function openHoleOverlay(seat){
  S.holePickSeat=seat;
  document.getElementById('ovTitle').textContent=`${seatNameOnly(seat, getSeatName(seat))} · 홀카드`;
  updateOvCount_(seat);
  // v2.5.0: Bottom Sheet 애니메이션
  const ov=document.getElementById('overlay');
  ov.style.display='flex';
  setTimeout(()=>ov.classList.add('show'),10);
  vibrate(HAPTIC.MEDIUM);
}
function pickCardOverlay(card,el){
  if(!S.holePickSeat) return;
  // 보드에 이미 있는 카드는 홀카드에서 선택 불가(요청사항 v1.1)
  if(S.board.includes(card)){ vibrate(HAPTIC.STRONG); return; }

  const seat=S.holePickSeat;
  const arr=S.holes[seat]||['',''];
  const existsIdx = arr.indexOf(card);
  if(existsIdx>=0){ arr[existsIdx]=''; vibrate(HAPTIC.LIGHT); }
  else{
    if(!arr[0]) arr[0]=card;
    else if(!arr[1]) arr[1]=card;
    else { arr[0]=arr[1]; arr[1]=card; }
    vibrate(HAPTIC.MEDIUM);
  }
  S.holes[seat]=arr; renderStackGrid(); updateOvCount_(seat);
  if(arr[0] && arr[1]){ setTimeout(closeOverlay,200); }
}
function updateOvCount_(seat){
  const arr=S.holes[seat]||['','']; const n=(arr[0]?1:0)+(arr[1]?1:0);
  document.getElementById('ovCount').textContent=` · 선택 ${n}/2`;
}
function clearHole(seat){ S.holes[seat]=['','']; renderStackGrid(); vibrate(HAPTIC.LIGHT); }
function closeOverlay(){
  // v2.5.0: Bottom Sheet 닫기 애니메이션
  const ov=document.getElementById('overlay');
  ov.classList.remove('show');
  setTimeout(()=>ov.style.display='none',300);
  S.holePickSeat=null;
  vibrate(HAPTIC.LIGHT);
}

/* ===== 커밋/리뷰 ===== */
function commitHand(){
  perfStart('commit');
  saveSettings_();

  // v3.3.0: 자동 hand_no 사용 (수동 입력 시 입력값 우선)
  const handNoInput = document.getElementById('handNo');
  const manualHandNo = handNoInput.value ? toInt(handNoInput.value) : 0;
  const handNo = manualHandNo > 0 ? manualHandNo : S.nextHandNo;

  const payload={
    client_uuid: uuid(),
    event_id:'',
    table_id:S.curTable||'',
    hand_no: handNo,
    start_street:S.startStreetInit,
    started_at:new Date().toISOString(),
    ended_at:'',
    btn_seat:S.btnSeat||'',
    board:getBoardObjectForSave(),
    pre_pot:S.prePot||'',
    winner_seat:'',
    pot_final:'',
    actions:S.actions.map(x=>Object.assign({},x)),
    holes:S.holes,
    stack_snapshot:S.stacks
  };
  const msg=document.getElementById('commitMsg');
  // v2.6.0: 낙관적 UI 업데이트 (즉시 피드백)
  msg.textContent='저장 중…';
  const btn=document.getElementById('commitBtn'); btn.disabled=true;

  // v2.3.0: Record는 HANDS/ACTIONS만 저장 (VIRTUAL 자동 전송 제거)
  google.script.run
    .withSuccessHandler(res=>{
      perfEnd('commit');
      msg.textContent=`완료: #${res.hand_no||'-'} (${res.hand_id})`;
      btn.disabled=false;
      vibrate(HAPTIC.STRONG);

      // v3.3.0: 커밋 후 다음 핸드 번호 증가
      S.nextHandNo++;
      updateHandNoDisplay();

      resetHandState(true); loadList();
    })
    .withFailureHandler(err=>{
      perfEnd('commit');
      msg.textContent='오류: '+(err.message||err);
      btn.disabled=false;
      vibrate(HAPTIC.STRONG);
    })
    .saveHand(payload);
}

/* === Record 탭 VIRTUAL 전송 (v3.2.0) === */
function renderVirtualRecordOptions(){
  const container=document.getElementById('virtualRecordOptions');

  if(!S.curTable || !S.activeSeatMap || Object.keys(S.activeSeatMap).filter(k=>S.activeSeatMap[k]).length===0){
    container.innerHTML='<span style="color:#64748b;">테이블과 참여 좌석을 먼저 설정하세요</span>';
    document.getElementById('sendVirtualRecordBtn').disabled=true;
    return;
  }

  document.getElementById('sendVirtualRecordBtn').disabled=false;

  const head={
    table_id:S.curTable,
    stacks_json:JSON.stringify(S.stacks),
    holes_json:JSON.stringify(S.holes)
  };

  const participants=extractParticipants(head,S.actions);

  if(participants.length===0){
    container.innerHTML='<span style="color:#64748b;">참가자 없음</span>';
    document.getElementById('sendVirtualRecordBtn').disabled=true;
    return;
  }

  const defaultBB=S.bbValue||0;

  // v3.3.0: 숫자 포맷팅 적용
  container.innerHTML=`
    <label style="display:flex; align-items:center; gap:4px;">
      <span style="color:#94a3b8;">BB</span>
      <input type="text" inputmode="numeric" id="bbRecordInput" value="${formatNumber(defaultBB)}" placeholder="1,000"
             style="width:60px; padding:2px 4px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.65rem;">
    </label>
    ${participants.map(p=>`
      <label style="display:flex; align-items:center; gap:2px; font-size:0.65rem;">
        <input type="checkbox" class="player-select-chk" value="${p.seat}" checked
               style="width:12px; height:12px; cursor:pointer; accent-color:#3b82f6;">
        <span style="font-weight:600;">${p.name}</span>
        <input type="text" inputmode="numeric" class="stack-override-input" data-seat="${p.seat}" value="${formatNumber(p.stack||0)}"
               style="width:60px; padding:2px 4px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.65rem;">
        <input type="checkbox" class="eliminated-chk" data-seat="${p.seat}"
               style="width:10px; height:10px; cursor:pointer; accent-color:#ef4444;">
      </label>
    `).join('')}
  `;
}

function sendRecordToVirtual(){
  if(!S.virtualSheetId){
    alert('Review 탭에서 VIRTUAL 시트 ID를 먼저 설정하세요');
    return;
  }

  if(!S.curTable){
    alert('테이블을 선택하세요');
    return;
  }

  const selectedSeats=Array.from(document.querySelectorAll('.player-select-chk:checked'))
    .map(chk=>chk.value);

  if(selectedSeats.length===0){
    alert('자막에 표시할 플레이어를 최소 1명 이상 선택하세요');
    return;
  }

  const eliminatedSeats=Array.from(document.querySelectorAll('.eliminated-chk:checked'))
    .map(chk=>chk.dataset.seat);

  // v3.3.0: 포맷팅된 값 파싱
  const stackOverrides={};
  document.querySelectorAll('.stack-override-input').forEach(input=>{
    stackOverrides[input.dataset.seat]=parseFormattedNumber(input.value);
  });

  const bbOverride=parseFormattedNumber(document.getElementById('bbRecordInput').value);

  const payload={
    selectedSeats,
    eliminatedSeats,
    stackOverrides,
    bbOverride
  };

  const tempHandId='record_'+Date.now();
  const btn=document.getElementById('sendVirtualRecordBtn');
  const msg=document.getElementById('virtualRecordMsg');

  btn.disabled=true;
  btn.textContent='전송 중...';
  msg.textContent='';

  google.script.run
    .withSuccessHandler(res=>{
      btn.disabled=false;
      btn.innerHTML='📤 VIRTUAL 전송';

      if(res && res.success){
        msg.textContent=`✅ Row ${res.row}`;
        msg.style.color='#22c55e';
        vibrate(HAPTIC.STRONG);
      }else{
        msg.textContent=`❌ 실패`;
        msg.style.color='#ef4444';
      }

      setTimeout(()=>{msg.textContent=''; msg.style.color='';},3000);
    })
    .withFailureHandler(err=>{
      btn.disabled=false;
      btn.innerHTML='📤 VIRTUAL 전송';
      msg.textContent=`❌ ${err.message||err}`;
      msg.style.color='#ef4444';
      setTimeout(()=>{msg.textContent=''; msg.style.color='';},3000);
    })
    .sendHandToVirtual(tempHandId,S.virtualSheetId,payload);
}

/* v3.0.0: 핸드 상세에서 VIRTUAL 전송 (복수 플레이어 선택 + 탈락 + 스택 수정) */
function sendCurrentHandToVirtual(){
  saveVirtualSettings_();
  if(!S.virtualSheetId){ alert('VIRTUAL 시트 ID를 먼저 설정하세요'); return; }
  if(!reviewState.selectedId){ alert('핸드가 선택되지 않았습니다'); return; }

  // 1. 선택된 플레이어 seat 배열 (자막에 표시할 플레이어)
  const selectedSeats = Array.from(document.querySelectorAll('.player-select-chk:checked'))
    .map(chk => chk.value);

  if(selectedSeats.length === 0){
    alert('자막에 표시할 플레이어를 최소 1명 이상 선택하세요');
    return;
  }

  // 2. 탈락 플레이어 seat 배열
  const eliminatedSeats = Array.from(document.querySelectorAll('.eliminated-chk:checked'))
    .map(chk => chk.dataset.seat);

  // 3. 수정된 스택 값 수집 (v3.3.0: 포맷팅된 값 파싱)
  const stackOverrides = {};
  document.querySelectorAll('.stack-override-input').forEach(input => {
    const seat = input.dataset.seat;
    const value = parseFormattedNumber(input.value);
    stackOverrides[seat] = value;
  });

  // 4. 수정된 BB 값 (v3.3.0: 포맷팅된 값 파싱)
  const bbOverride = parseFormattedNumber(document.getElementById('bbOverrideInput').value);

  // 5. payload 구성
  const payload = {
    selectedSeats: selectedSeats,
    eliminatedSeats: eliminatedSeats,
    stackOverrides: stackOverrides,
    bbOverride: bbOverride
  };

  console.log('[VIRTUAL] 전송 payload:', payload);

  const btn = document.getElementById('sendToVirtualDetailBtn');
  const msg = document.getElementById('virtualDetailMsg');

  btn.disabled = true;
  btn.textContent = '전송 중...';
  msg.textContent = '';

  google.script.run
    .withSuccessHandler(res=>{
      console.log('VIRTUAL 전송 응답 (상세뷰):', res);
      btn.disabled = false;
      btn.textContent = '📤 VIRTUAL 전송';

      if(res && res.success){
        msg.textContent = `✅ 전송 성공! Row ${res.row} 업데이트됨 (선택: ${selectedSeats.length}명)`;
        msg.style.color = '#22c55e';

        // 리스트 항목에도 시각적 표시
        const selectedCard = document.querySelector('#list .seatCard.selected');
        if(selectedCard && !selectedCard.dataset.sent){
          selectedCard.style.borderColor = '#22c55e';
          selectedCard.dataset.sent = 'true';
        }
      }else{
        console.log('전송 실패 - res:', res);
        msg.textContent = `❌ 전송 실패: ${res.reason||'알 수 없는 오류'}`;
        msg.style.color = '#ef4444';
      }

      setTimeout(()=>{msg.textContent=''; msg.style.color='';}, 5000);
    })
    .withFailureHandler(err=>{
      btn.disabled = false;
      btn.textContent = '📤 VIRTUAL 전송';
      msg.textContent = `❌ 오류: ${err.message||err}`;
      msg.style.color = '#ef4444';
      setTimeout(()=>{msg.textContent=''; msg.style.color='';}, 5000);
    })
    .sendHandToVirtual(reviewState.selectedId, S.virtualSheetId, payload);
}
function getBoardObjectForSave(){
  const b=[...S.board]; // [f1,f2,f3,turn,river]
  return {f1:b[0]||'',f2:b[1]||'',f3:b[2]||'',turn:b[3]||'',river:b[4]||''};
}

/* === Review 상태 관리 (v1.2.0) === */
const reviewState={page:1,size:10,total:0,loading:false,hasMore:true,selectedId:null};

function loadList(reset){
  if(reset){ reviewState.page=1; reviewState.hasMore=true; reviewState.total=0; }
  if(reviewState.loading||!reviewState.hasMore) return;
  reviewState.loading=true;
  const box=document.getElementById('list');
  if(reset) box.innerHTML='<div class="small muted" style="padding:8px">불러오는 중…</div>';
  google.script.run.withSuccessHandler(data=>{
    reviewState.loading=false;
    if(data.error){ box.innerHTML=`<div class="small" style="color:#ffbdbd">오류: ${data.error}</div>`; return; }
    reviewState.total=data.total;
    document.getElementById('listInfo').textContent=`총 ${reviewState.total}건 (${reviewState.page}페이지)`;
    if(reset) box.innerHTML='';
    if(!data.items||data.items.length===0){ reviewState.hasMore=false; return; }
    data.items.forEach(it=>box.appendChild(createListItem(it)));
    reviewState.page++;
    reviewState.hasMore=(box.children.length<reviewState.total);
  }).withFailureHandler(err=>{
    reviewState.loading=false;
    box.innerHTML=`<div class="small" style="color:#ffbdbd">로드 오류: ${(err.message||err)}</div>`;
  }).queryHands({},{num:reviewState.page,size:reviewState.size});
}

function createListItem(it){
  const div=document.createElement('div'); div.className='seatCard'; div.dataset.handId=it.hand_id;
  const arr=boardToArray(it.board||it)||[];
  const boardBadgesHTML=arr.slice(0,3).map(cs=>renderCardBadge(cs,'small')).join('')+(arr.length>3?'...':'');

  div.innerHTML=`
    <div><b>#${it.hand_no||'-'}</b> · Table ${it.table_id||'-'} · BTN ${it.btn_seat||'-'} · <span class="badge">${it.start_street||'-'}</span></div>
    <div class="small muted">${it.started_at||''}</div>
    <div class="boardSmall">${boardBadgesHTML||'<span class="muted">-</span>'}</div>`;
  div.onclick=()=>selectAndLoadDetail(it.hand_id,div);
  return div;
}

function selectAndLoadDetail(id,el){
  document.querySelectorAll('#list .seatCard').forEach(d=>d.classList.remove('selected'));
  el.classList.add('selected');
  reviewState.selectedId=id;
  loadDetail(id);
}

/* 상세 */
function loadDetail(id){
  const d = document.getElementById('detail');
  if (!id || String(id).trim() === '') { d.innerHTML = `<div class="small" style="color:#ffbdbd">잘못된 hand id</div>`; return; }
  d.textContent = '상세 불러오는 중…';
  google.script.run
    .withSuccessHandler(x=>{
      try{
        if (!x) { d.innerHTML = `<div class="small" style="color:#ffbdbd">서버 응답 없음(undefined) · id=${id}</div>`; return; }
        if (x.error) { d.innerHTML = `<div class="small" style="color:#ffbdbd">오류: ${x.error} · id=${id}</div>`; return; }
        const head = (x.head && typeof x.head === 'object') ? x.head : {};
        const acts = Array.isArray(x.acts) ? x.acts : (Array.isArray(x.actions) ? x.actions : []);
        const stacks = safeJson_(head.stacks_json||{});
        if (!Object.keys(head).length) {
          const sample = JSON.stringify(x).slice(0,400);
          d.innerHTML = `<div class="small" style="color:#ffbdbd">형식 오류(빈 head) · id=${id}<br/><code>${sample}</code></div>`;
          return;
        }
        d.innerHTML = renderDetailContent(head, acts);
      }catch(err){
        const msg=(err && (err.message||err.toString()))||'unknown';
        d.innerHTML = `<div class="small" style="color:#ffbdbd">클라이언트 렌더 오류: ${msg} · id=${id}</div>`;
      }
    })
    .withFailureHandler(err=>{
      const msg = (err && (err.message || err.toString())) || 'unknown failure';
      d.innerHTML = `<div class="small" style="color:#ffbdbd">로드 실패: ${msg} · id=${id}</div>`;
    })
    .getHandDetail(id);
}

/* ===== Review 렌더 유틸 ===== */
function cardCode(cs){
  if (!cs) return '';
  if (typeof cs === 'string') return cs.trim();
  if (cs.card) return String(cs.card).trim();
  if (cs.rank && cs.suit){
    const r = String(cs.rank).toUpperCase().replace('10','T');
    const map={spade:'s',heart:'h',diamond:'d',club:'c','S':'s','H':'h','D':'d','C':'c'};
    const sRaw=String(cs.suit); const s=map[sRaw]||map[sRaw.toLowerCase()]||sRaw.toLowerCase();
    return r+s;
  }
  if (Array.isArray(cs) && cs.length>=2){
    const r=String(cs[0]).toUpperCase().replace('10','T');
    const s=String(cs[1]).toLowerCase(); return r+s;
  }
  return '';
}
function boardToArray(b){
  if(!b) return [];
  if(Array.isArray(b)) return b.map(cardCode).filter(Boolean);
  // 서버 응답 포맷: {f1,f2,f3,turn,river} 또는 {board_f1,board_f2,...}
  const keys=['f1','f2','f3','turn','river'].map(k=>cardCode(b[k])).filter(Boolean);
  if(keys.length) return keys;
  const keys2=['board_f1','board_f2','board_f3','board_turn','board_river'].map(k=>cardCode(b[k])).filter(Boolean);
  return keys2.length?keys2:(b.board?boardToArray(b.board):[]);
}
function boardBadges(b){
  const arr=boardToArray(b); if(!arr.length) return '<span class="muted">-</span>';
  return `<div style="display:flex;gap:10px;flex-wrap:wrap">${arr.map(cs=>renderCardBadge(cs)).join('')}</div>`;
}
function getSeatName(seat){
  const s = (S.roster[S.curTable]||[]).find(x=>toInt(x.seat)===toInt(seat));
  return s?.player || `Seat ${seat}`;
}
function seatNameOnlyFmt(seat){ return seatNameOnly(seat, getSeatName(seat)); }
function groupByStreet(acts){
  const g={PREFLOP:[],FLOP:[],TURN:[],RIVER:[]};
  (acts||[]).forEach(a=>{ const s=(a.street||'').toUpperCase(); if(g[s]) g[s].push(a); else g.RIVER.push(a); });
  return g;
}
function formatStreetSection(title,arr,tableId,idx){
  if(!arr||!arr.length) return '';
  const badges=arr.map(a=>{
    const fullName=getSeatNameByTable(tableId,a.seat);
    const name=seatNameOnly(a.seat,fullName);
    const amt=a.amount_input?` ${formatCompact(toInt(a.amount_input))}`:'';
    const k=(a.action||'').toUpperCase();
    const cl=k==='CHECK'?'act-chk':k==='CALL'?'act-call':k==='BET'?'act-bet':k==='RAISE'?'act-raise':k==='ALLIN'?'act-allin':'act-fold';
    return `<span class="actBadge ${cl}">${name} ${a.action}${amt}</span>`;
  }).join('');
  const collapseId=`street_${idx}`;
  return `<div class="streetRow">
    <span class="streetTitle" onclick="toggleStreet('${collapseId}')">▼ ${title}(${arr.length})</span>
    <span id="${collapseId}" class="streetBadges">${badges}</span>
  </div>`;
}
/* === Review 상세 렌더링 헬퍼 (v3.1.0) === */
function renderCardBadge(cs,size='large'){
  const cc=cardCode(cs); if(!cc) return '';
  const suit=cc.slice(-1), r=cc.slice(0,-1);
  const sym=suit==='s'?'♠':suit==='h'?'♥':suit==='d'?'♦':'♣';
  const cl=suit==='s'?'cb-s':suit==='h'?'cb-h':suit==='d'?'cb-d':'cb-c';
  const sizeClass=size==='compact'?'cardBadgeSmall':(size==='small'?'cardBadgeSmall':'cardBadge');
  return `<span class="${sizeClass} ${cl}">${r}${sym}</span>`;
}

function toggleStreet(id){
  const el=document.getElementById(id);
  if(!el) return;
  if(el.style.display==='none'){
    el.style.display='inline';
    el.previousElementSibling.textContent=el.previousElementSibling.textContent.replace('▶','▼');
  }else{
    el.style.display='none';
    el.previousElementSibling.textContent=el.previousElementSibling.textContent.replace('▼','▶');
  }
}

function calculateFinalPot(head,acts){
  if(head.pot_final) return toInt(head.pot_final);
  let maxPot=0;
  (acts||[]).forEach(a=>{const val=toInt(a.pot_after); if(val>maxPot) maxPot=val;});
  return maxPot||toInt(head.pre_pot)||0;
}

function formatCompact(num){
  num=toInt(num);
  if(num>=1000000) return (num/1000000).toFixed(1)+'M';
  if(num>=1000){
    const k=num/1000;
    return (k%1===0?k.toFixed(0):k.toFixed(1))+'k';
  }
  return num.toString();
}

function formatPotWithBB(pot,bb){
  pot=toInt(pot);
  if(!bb||bb===0) return formatCompact(pot);
  const bbVal=(pot/bb).toFixed(1);
  return `${formatCompact(pot)}(${bbVal}BB)`;
}

function renderPotHeader(head,acts){
  const pot=calculateFinalPot(head,acts);
  const bb=toInt(localStorage.getItem('phl_bbSize')||0);
  const handIdShort=(head.hand_id||'').slice(0,8)+'...';
  const bbInfo=bb>0?` BB${formatCompact(bb)}`:'';
  return `<div class="potHeader">
    <div><b>#${head.hand_no||'-'}</b> T${head.table_id||'-'} BTN${head.btn_seat||'-'}${bbInfo} <span style="color:#64748b">${handIdShort}</span></div>
    <div><b>${formatPotWithBB(pot,bb)}</b></div>
  </div>`;
}

function getSeatNameByTable(tableId,seat){
  const roster=S.roster[tableId]||[];
  const s=roster.find(x=>toInt(x.seat)===toInt(seat));
  return s?.player || `Seat ${seat}`;
}

function renderPlayerRows(head){
  const stacks=safeJson_(head.stacks_json||'{}');
  const holes=safeJson_(head.holes_json||'{}');
  const btnSeat=toInt(head.btn_seat);
  const tableId=head.table_id;
  const seats=Object.keys(stacks).sort((a,b)=>toInt(a)-toInt(b));
  if(!seats.length) return '';

  const rows=seats.map(s=>{
    const seat=toInt(s);
    const fullName=getSeatNameByTable(tableId,seat);
    const name=seatNameOnly(seat,fullName);
    const pos=(seat===btnSeat)?' BTN':'';
    const holeCards=holes[s]||[];
    const holeHTML=(holeCards[0]&&holeCards[1])
      ?renderCardBadge(holeCards[0],'compact')+renderCardBadge(holeCards[1],'compact')
      :'<span class="muted" style="font-size:0.7rem">-</span>';
    const stack=stacks[s]?formatCompact(toInt(stacks[s])):'-';
    return `<div class="playerRow">
      <span class="playerName">${name}${pos}</span>
      <span class="playerHole">${holeHTML}</span>
      <span class="playerStack">${stack}</span>
    </div>`;
  }).join('');

  return `<div class="playerSection">${rows}</div>`;
}

function renderPotFooter(head,acts){
  return '';
}

function renderDetailContent(head,acts){
  const b=head.board||head||{}; const g=groupByStreet(acts||[]);
  const tableId=head.table_id;
  const participants = extractParticipants(head, acts);
  const boardArr=boardToArray(b);

  return `${renderPotHeader(head,acts)}

    <div class="boardSection">
      ${boardArr.length>0?`<div style="display:flex;gap:3px;flex-wrap:wrap">${boardArr.map(cs=>renderCardBadge(cs,'compact')).join('')}</div>`:'<span class="muted" style="font-size:0.7rem">-</span>'}
    </div>

    ${renderPlayerRows(head)}

    <div class="sectionDivider"></div>

    ${formatStreetSection('PREFLOP',g.PREFLOP,tableId,0)}
    ${formatStreetSection('FLOP',g.FLOP,tableId,1)}
    ${formatStreetSection('TURN',g.TURN,tableId,2)}
    ${formatStreetSection('RIVER',g.RIVER,tableId,3)}

    ${renderPotFooter(head,acts)}

    ${renderVirtualSection(head.hand_id, participants)}`;
}

function renderVirtualSection(handId, participants){
  const defaultBB = S.bbValue || 0;

  const chunks = [];
  const chunkSize = 2;
  for(let i = 0; i < participants.length; i += chunkSize){
    chunks.push(participants.slice(i, i + chunkSize));
  }

  // v3.3.0: 숫자 포맷팅 적용
  return `
    <div style="margin-top:8px; padding:8px; background:#0e1322; border-radius:4px; border:1px solid #1e293b;">
      <div style="font-size:0.7rem; margin-bottom:6px; display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
        <label style="display:flex; align-items:center; gap:4px;">
          <span style="color:#94a3b8;">BB</span>
          <input type="text" inputmode="numeric" id="bbOverrideInput" value="${formatNumber(defaultBB)}" placeholder="1,000"
                 style="width:70px; padding:3px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.7rem;">
        </label>
        ${chunks.map((chunk, chunkIdx) => chunk.map(p => `
          <label style="display:flex; align-items:center; gap:3px; font-size:0.7rem;">
            <input type="checkbox" class="player-select-chk" value="${p.seat}" checked
                   style="width:14px; height:14px; cursor:pointer; accent-color:#3b82f6;">
            <span style="font-weight:600;">${p.name}</span>
            <input type="text" inputmode="numeric" class="stack-override-input" data-seat="${p.seat}" value="${formatNumber(p.stack || 0)}" placeholder="0"
                   style="width:70px; padding:3px; background:#0f1320; border:1px solid #2a3249; border-radius:3px; color:#e7eaf0; font-size:0.7rem;">
            <input type="checkbox" class="eliminated-chk" data-seat="${p.seat}"
                   style="width:12px; height:12px; cursor:pointer; accent-color:#ef4444;">
          </label>
        `).join('')).join('')}
      </div>

      <button id="sendToVirtualDetailBtn" class="btnPrimary" onclick="sendCurrentHandToVirtual()"
              style="width:100%; padding:6px; font-size:0.75rem; font-weight:600;">
        📤 전송
      </button>

      <div id="virtualDetailMsg" style="margin-top:4px; font-size:0.65rem; text-align:center;"></div>
    </div>
  `;
}

/* ===== 참가자 추출 (핸드 상세 → 플레이어 목록 + 스택 데이터) ===== */
function extractParticipants(head, acts){
  // acts에서 seat 추출
  const seats = new Set();
  (acts||[]).forEach(a => {
    if(a.seat) seats.add(String(a.seat));
  });

  // holes_json에서도 추출 (액션 없이 폴드한 경우 대비)
  const holes = safeJson_(head.holes_json||'{}');
  Object.keys(holes||{}).forEach(seat => seats.add(String(seat)));

  // stacks_json에서 최종 스택 추출
  const stacks = safeJson_(head.stacks_json||'{}');

  // roster에서 이름 매칭
  const tableId = head.table_id;
  const roster = (S.roster && S.roster[tableId]) || [];

  return Array.from(seats).sort((a,b)=>toInt(a)-toInt(b)).map(seat => {
    const player = roster.find(p => String(p.seat) === String(seat));
    const stack = stacks[seat] ? toInt(stacks[seat]) : 0;

    return {
      seat: seat,
      name: player && player.player ? player.player : `Seat ${seat}`,
      stack: stack
    };
  });
}

/* ===== 유틸 ===== */
function sumObj(o){ return Object.values(o||{}).reduce((a,b)=>a+(toInt(b)||0),0); }
function toInt(v){ const n=parseInt(v,10); return isNaN(n)?0:n; }
function uuid(){ return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)); }
function safeJson_(s){ try{return typeof s==='string'?JSON.parse(s||'{}'):(s||{});}catch(e){return {}} }

/* v3.3.0: 숫자 포맷팅 (3자리마다 콤마) */
function formatNumber(num){
  const n = toInt(num);
  return n.toLocaleString('en-US');
}
function parseFormattedNumber(str){
  if(!str) return 0;
  const cleaned = String(str).replace(/,/g, '');
  return toInt(cleaned);
}

/* ===== v2.9.0: 테스트 함수 (브라우저 콘솔에서 실행) ===== */
function testKeyplayerSort() {
  console.log('=== v2.9.0 Keyplayer Sort Test ===');

  // Test 1: 키플레이어 2개 테이블
  const test1Tables = ['1', '15', '2', '23', '3'];
  const test1Roster = {
    '15': [{seat: 1, keyplayer: true}, {seat: 2, keyplayer: false}],
    '23': [{seat: 1, keyplayer: true}],
    '1': [{seat: 1, keyplayer: false}],
    '2': [{seat: 1, keyplayer: false}],
    '3': [{seat: 1, keyplayer: false}]
  };
  const result1 = sortTablesByKeyplayer(test1Tables, test1Roster);
  const expected1 = ['15', '23', '1', '2', '3'];
  console.log('Test 1 - 키플레이어 2개 테이블:', result1.join(',') === expected1.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected1);
  console.log('  Got:', result1);

  // Test 2: 키플레이어 없음
  const test2Tables = ['1', '2', '3'];
  const test2Roster = {
    '1': [{seat: 1, keyplayer: false}],
    '2': [{seat: 1, keyplayer: false}],
    '3': [{seat: 1, keyplayer: false}]
  };
  const result2 = sortTablesByKeyplayer(test2Tables, test2Roster);
  const expected2 = ['1', '2', '3'];
  console.log('Test 2 - 키플레이어 없음:', result2.join(',') === expected2.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected2);
  console.log('  Got:', result2);

  // Test 3: keyplayer 컬럼 없음 (하위 호환)
  const test3Tables = ['3', '1', '2'];
  const test3Roster = {
    '1': [{seat: 1, player: 'Alice', chips: 10000}],
    '2': [{seat: 1, player: 'Bob'}]
  };
  const result3 = sortTablesByKeyplayer(test3Tables, test3Roster);
  const expected3 = ['1', '2', '3'];
  console.log('Test 3 - keyplayer 컬럼 없음:', result3.join(',') === expected3.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected3);
  console.log('  Got:', result3);

  // Test 4: 빈 배열
  const result4 = sortTablesByKeyplayer([], test1Roster);
  console.log('Test 4 - 빈 배열:', result4.length === 0 ? '✅ PASS' : '❌ FAIL');

  // Test 5: roster 없음
  const result5 = sortTablesByKeyplayer(['3', '1', '2'], {});
  const expected5 = ['1', '2', '3'];
  console.log('Test 5 - roster 없음:', result5.join(',') === expected5.join(',') ? '✅ PASS' : '❌ FAIL');
  console.log('  Expected:', expected5);
  console.log('  Got:', result5);

  console.log('=== Test Complete ===');
}
</script>
</body>
</html>
